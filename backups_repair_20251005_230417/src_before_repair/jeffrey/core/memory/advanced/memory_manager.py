from __future__ import annotations

import json

# V1.1 PATCH - Fix pour INT-COMP-04 (fuite mÃ©moire)
import logging
import os
import re
from datetime import datetime, timedelta
from typing import Any

# Import du nouveau module Sprint 191
# from core.memory.affective_link_resolver import AffectiveLinkResolver  # Module not yet available


logger = logging.getLogger("memory.manager")


class MemoryManager:
    """
    GÃ¨re la mÃ©moire longue durÃ©e de Jeffrey :
    - Ã‰motions vÃ©cues dans le temps
    - Souvenirs Ã©motionnels
    - Ã‰vÃ©nements marquants
    - DonnÃ©es Ã  long terme
    - Phrases utilisateur
    """

    def __init__(
        self,
        memory_file: str = "data/memory/jeffrey_memory.json",
        read_only: bool = False,
    ):
        self.memory_file = memory_file
        self.read_only = read_only
        self.memory: dict[str, Any] = {
            "emotional_history": [],
            "events": [],
            "knowledge": {},
            "personality_traits": {},
            "important_people": {},
            "happy_memories": [],
            "user_phrases": [],
            "emotional_links": {},  # Nouveau champ Sprint 191
        }
        self._load_memory()

        # Initialisation du rÃ©solveur de liens affectifs (Sprint 191)
        self.affective_link_resolver = AffectiveLinkResolver(
            storage_path="data/memory/affective_links.json",
            max_topics=100,
            association_threshold=0.6,
        )

    def _load_memory(self):
        if os.path.exists(self.memory_file):
            try:
                with open(self.memory_file, encoding="utf-8") as f:
                    self.memory = json.load(f)
            except Exception:
                pass

    def _save_memory(self):
        if self.read_only:
            return  # Ne pas sauvegarder en mode lecture seule

        os.makedirs(os.path.dirname(self.memory_file), exist_ok=True)
        with open(self.memory_file, "w", encoding="utf-8") as f:
            json.dump(self.memory, f, indent=2, ensure_ascii=False)

    # ðŸ”¹ Gestion des Ã©motions dans le temps

    def log_emotion(self, emotion: str, intensity: float = 0.5, context: str | None = None):
        entry = {
            "emotion": emotion,
            "intensity": round(float(intensity), 2),
            "timestamp": datetime.now().isoformat(),
            "context": context or "",
        }
        self.memory["emotional_history"].append(entry)
        self._save_memory()

    def get_recent_emotions(self, limit: int = 10) -> list[dict[str, Any]]:
        return self.memory["emotional_history"][-limit:]

    # ðŸ”¹ Gestion des souvenirs Ã©motionnels

    def add_memory_event(
        self,
        title: str,
        emotion: str,
        impact: float = 0.5,
        details: str | None = None,
    ):
        event = {
            "title": title,
            "emotion": emotion,
            "impact": round(float(impact), 2),
            "details": details or "",
            "timestamp": datetime.now().isoformat(),
        }
        self.memory["events"].append(event)
        self._save_memory()

    def get_all_events(self) -> list[dict[str, Any]]:
        return self.memory["events"]

    # ðŸ”¹ Ajout de connaissances ou traits persistants

    def remember_fact(self, key: str, value: Any):
        self.memory["knowledge"][key] = value
        self._save_memory()

    def remember_trait(self, trait: str, description: str):
        self.memory["personality_traits"][trait] = description
        self._save_memory()

    def get_knowledge(self) -> dict[str, Any]:
        return self.memory["knowledge"]

    def get_traits(self) -> dict[str, str]:
        return self.memory["personality_traits"]

    # ðŸ”¹ Relations avec des personnes importantes

    def link_person(self, name: str, relation: str, details: str | None = None):
        self.memory["important_people"][name] = {
            "relation": relation,
            "details": details or "",
            "last_updated": datetime.now().isoformat(),
        }
        self._save_memory()

    def get_linked_people(self) -> dict[str, Any]:
        return self.memory["important_people"]

    # ðŸ”¹ Export complet

    def export_memory(self) -> dict[str, Any]:
        return self.memory.copy()

    def clear_memory(self):
        self.memory = {
            "emotional_history": [],
            "events": [],
            "knowledge": {},
            "personality_traits": {},
            "important_people": {},
            "happy_memories": [],
        }
        self._save_memory()

    def describe_emotional_journal(self, limit: int = 10) -> str:
        """
        GÃ©nÃ¨re un rÃ©sumÃ© lisible de l'historique Ã©motionnel.
        """
        emotions = self.get_recent_emotions(limit)
        if not emotions:
            return "Aucune Ã©motion enregistrÃ©e."

        lines = ["ðŸ§  Journal Ã©motionnel de Jeffrey (rÃ©cent â†’ ancien) :\n"]
        for e in reversed(emotions):
            date = datetime.fromisoformat(e["timestamp"]).strftime("%d/%m/%Y %H:%M")
            context = f" âž¤ {e['context']}" if e["context"] else ""
            lines.append(f"[{date}] ({e['emotion']} â€“ intensitÃ© {e['intensity']}){context}")

        return "\n".join(lines)

    def store_happy_memory(
        self,
        title: str,
        reason: str,
        source: str = "David",
        tags: list[str] | None = None,
    ):
        """
        Enregistre un souvenir heureux dÃ©clenchÃ© par une interaction positive.
        Peut Ãªtre utilisÃ© plus tard pour le rÃ©confort Ã©motionnel.
        """
        memory_entry = {
            "type": "souvenir_heureux",
            "title": title,
            "reason": reason,
            "source": source,
            "tags": tags or [],
            "timestamp": datetime.now().isoformat(),
        }
        self.memory.setdefault("happy_memories", []).append(memory_entry)
        self._save_memory()

    def get_happy_memories(self, limit: int = 10) -> list[dict[str, Any]]:
        """
        Retourne les derniers souvenirs heureux enregistrÃ©s.
        """
        return self.memory.get("happy_memories", [])[-limit:]

    # ðŸ”¹ Gestion des phrases utilisateur

    def store_user_phrase(self, phrase: str, emotion: str | None = None, affectif: bool = False) -> dict[str, Any]:
        """
        Stocke une phrase utilisateur dans la mÃ©moire avec des mÃ©tadonnÃ©es.

        Args:
            phrase (str): La phrase de l'utilisateur Ã  stocker
            emotion (str, optional): L'Ã©motion associÃ©e Ã  la phrase
            affectif (bool): Si la phrase a un contenu affectif (je t'aime, merci, etc.)

        Returns:
            dict: L'entrÃ©e crÃ©Ã©e dans la mÃ©moire
        """
        # VÃ©rifier si la phrase est vide
        if not phrase or not phrase.strip():
            return {}

        # Nettoyer la phrase (supprimer les caractÃ¨res spÃ©ciaux)
        phrase_clean = re.sub(r'[^\w\s.,!?\'"-:;]', "", phrase.strip())

        # VÃ©rifier si la phrase contient du contenu affectif
        if not affectif:
            affectif_patterns = [
                r'\bje\s+t[\'"]aime\b',
                r"\bmerci\b",
                r'\bje\s+t[\'"]adore\b',
                r"\btu\s+es\s+g[eÃ©]nial\b",
                r"\btu\s+es\s+super\b",
            ]
            affectif = any(re.search(pattern, phrase_clean.lower()) for pattern in affectif_patterns)

        # VÃ©rifier si la phrase existe dÃ©jÃ  pour Ã©viter les doublons
        for existing_phrase in self.memory.get("user_phrases", []):
            if existing_phrase.get("phrase") == phrase_clean:
                # Mettre Ã  jour le compteur d'occurrences et la date
                existing_phrase["occurrences"] += 1
                existing_phrase["last_seen"] = datetime.now().isoformat()
                self._save_memory()
                return existing_phrase

        # CrÃ©er l'entrÃ©e
        entry = {
            "phrase": phrase_clean,
            "timestamp": datetime.now().isoformat(),
            "last_seen": datetime.now().isoformat(),
            "emotion": emotion or "neutral",
            "affectif": affectif,
            "occurrences": 1,
            "tags": ["affectif"] if affectif else [],
        }

        # Ajouter des tags basÃ©s sur le contenu
        if "?" in phrase_clean:
            entry["tags"].append("question")
        if "!" in phrase_clean:
            entry["tags"].append("exclamation")
        if len(phrase_clean.split()) > 15:
            entry["tags"].append("longue")

        # Ajouter Ã  la mÃ©moire
        self.memory.setdefault("user_phrases", []).append(entry)
        self._save_memory()

        return entry

    def get_user_phrases(
        self, limit: int = 20, tag: str | None = None, affectif_only: bool = False
    ) -> list[dict[str, Any]]:
        """
        RÃ©cupÃ¨re les phrases utilisateur stockÃ©es.

        Args:
            limit (int): Nombre maximum de phrases Ã  rÃ©cupÃ©rer
            tag (str, optional): Filtrer par tag spÃ©cifique
            affectif_only (bool): RÃ©cupÃ©rer uniquement les phrases affectives

        Returns:
            list: Liste des phrases correspondant aux critÃ¨res
        """
        phrases = self.memory.get("user_phrases", [])

        # Appliquer les filtres
        if tag:
            phrases = [p for p in phrases if tag in p.get("tags", [])]
        if affectif_only:
            phrases = [p for p in phrases if p.get("affectif", False)]

        # Trier par date dÃ©croissante
        phrases.sort(key=lambda x: x.get("last_seen", ""), reverse=True)

        return phrases[:limit]

    def mark_as_favorite_phrase(self, phrase: str, emotion_tags: dict[str, float] | None = None) -> bool:
        """
        Marque une phrase comme favorite pour pouvoir la rejouer plus tard.

        Args:
            phrase (str): La phrase Ã  marquer comme favorite
            emotion_tags (Dict[str, float], optional): Tags Ã©motionnels associÃ©s Ã  la phrase

        Returns:
            bool: True si la phrase a Ã©tÃ© marquÃ©e comme favorite, False sinon
        """
        phrases = self.memory.get("user_phrases", [])

        # VÃ©rifier si la phrase existe dÃ©jÃ 
        for p in phrases:
            if p.get("phrase") == phrase:
                # Marquer comme favorite si ce n'est pas dÃ©jÃ  le cas
                if "is_favorite" not in p or not p["is_favorite"]:
                    p["is_favorite"] = True
                    p["favorite_date"] = datetime.now().isoformat()

                    # Ajouter le tag "favorite" s'il n'existe pas dÃ©jÃ 
                    if "favorite" not in p.get("tags", []):
                        p.setdefault("tags", []).append("favorite")

                    # Ajouter les tags Ã©motionnels si fournis
                    if emotion_tags:
                        p["emotion_tags"] = emotion_tags

                    self._save_memory()
                    return True
                return False  # DÃ©jÃ  marquÃ©e comme favorite

        # Si la phrase n'existe pas, l'ajouter comme nouvelle phrase favorite
        if phrase and phrase.strip():
            entry = {
                "phrase": phrase,
                "timestamp": datetime.now().isoformat(),
                "last_seen": datetime.now().isoformat(),
                "favorite_date": datetime.now().isoformat(),
                "is_favorite": True,
                "emotion": "neutral",
                "affectif": True,
                "occurrences": 1,
                "tags": ["favorite", "affectif"],
            }

            # Ajouter les tags Ã©motionnels si fournis
            if emotion_tags:
                entry["emotion_tags"] = emotion_tags

            self.memory.setdefault("user_phrases", []).append(entry)
            self._save_memory()
            return True

        return False

    # ðŸ”¹ Gestion des liens affectifs entre sujets (Sprint 191)

    def analyze_emotional_links(self, text: str, emotion: str, intensity: float = 0.5) -> dict[str, Any]:
        """
        Analyse un texte pour dÃ©tecter les sujets et leurs liens Ã©motionnels.
        Utilise le AffectiveLinkResolver pour construire un graphe Ã©motionnel.

        Args:
            text (str): Texte Ã  analyser
            emotion (str): Ã‰motion dominante associÃ©e au texte
            intensity (float): IntensitÃ© de l'Ã©motion (0-1)

        Returns:
            Dict[str, Any]: RÃ©sultat de l'analyse avec graphe Ã©motionnel et sujets dÃ©tectÃ©s
        """
        # DÃ©lÃ©guer l'analyse au rÃ©solveur de liens
        result = self.affective_link_resolver.process_text(text, emotion, intensity)

        # Stocker les rÃ©sultats dans la mÃ©moire
        if result and result["topics"]:
            # Mettre Ã  jour le graphe Ã©motionnel dans la mÃ©moire
            self.memory["emotional_links"] = {
                "last_updated": datetime.now().isoformat(),
                "topics": result["topics"],
                "graph": result["graph"],
            }
            self._save_memory()

        return result

    def get_topic_emotions(self, topic: str) -> dict[str, Any]:
        """
        RÃ©cupÃ¨re les Ã©motions associÃ©es Ã  un sujet spÃ©cifique.

        Args:
            topic (str): Sujet Ã  analyser

        Returns:
            Dict[str, Any]: Informations Ã©motionnelles sur le sujet
        """
        return self.affective_link_resolver.get_topic_emotion(topic)

    def get_related_topics(self, topic: str, threshold: float = 0.5) -> list[dict[str, Any]]:
        """
        Trouve les sujets liÃ©s Ã©motionnellement Ã  un sujet donnÃ©.

        Args:
            topic (str): Sujet de rÃ©fÃ©rence
            threshold (float): Seuil minimal de force du lien

        Returns:
            List[Dict[str, Any]]: Liste des sujets liÃ©s avec leur force et Ã©motions partagÃ©es
        """
        return self.affective_link_resolver.get_related_topics(topic, threshold)

    def get_emotional_graph(self) -> dict[str, Any]:
        """
        RÃ©cupÃ¨re le graphe Ã©motionnel complet des liens entre sujets.

        Returns:
            Dict[str, Any]: Graphe Ã©motionnel avec nÅ“uds et liens
        """
        # RÃ©soudre les liens pour le graphe complet
        return self.affective_link_resolver.resolve_links()

    def get_emotional_insights(self) -> list[dict[str, Any]]:
        """
        RÃ©cupÃ¨re des insights sur les associations Ã©motionnelles entre sujets.

        Returns:
            List[Dict[str, Any]]: Liste d'insights Ã©motionnels
        """
        return self.affective_link_resolver.get_emotional_insights()

    def clean_outdated_topics(self, days_threshold: int = 30) -> int:
        """
        Nettoie les sujets qui n'ont pas Ã©tÃ© mentionnÃ©s depuis longtemps.

        Args:
            days_threshold (int): Nombre de jours d'inactivitÃ© avant suppression

        Returns:
            int: Nombre de sujets supprimÃ©s
        """
        return self.affective_link_resolver.clean_old_topics(days_threshold)

    def get_favorite_phrases(self, limit: int = 10) -> list[dict[str, Any]]:
        """
        RÃ©cupÃ¨re les phrases marquÃ©es comme favorites.

        Args:
            limit (int): Nombre maximum de phrases Ã  rÃ©cupÃ©rer

        Returns:
            list: Liste des phrases favorites
        """
        phrases = self.memory.get("user_phrases", [])
        favorites = [p for p in phrases if p.get("is_favorite", False)]

        # Trier par date de marquage comme favorite
        favorites.sort(key=lambda x: x.get("favorite_date", ""), reverse=True)

        return favorites[:limit]

    # V1.1 PATCH - MÃ©thodes de nettoyage mÃ©moire pour rÃ©soudre INT-COMP-04
    def cleanup_old_emotional_history(self, max_days=30):
        """
        Nettoie l'historique Ã©motionnel en conservant uniquement
        les entrÃ©es plus rÃ©centes que max_days.

        Args:
            max_days (int): Nombre de jours Ã  conserver

        Returns:
            int: Nombre d'entrÃ©es supprimÃ©es
        """
        if not self.memory.get("emotional_history"):
            return 0

        cutoff_date = (datetime.now() - timedelta(days=max_days)).isoformat()
        before_count = len(self.memory["emotional_history"])

        # Conserver uniquement les entrÃ©es plus rÃ©centes que la date limite
        self.memory["emotional_history"] = [
            entry for entry in self.memory["emotional_history"] if entry.get("timestamp", "") >= cutoff_date
        ]

        # Sauvegarder les changements
        self._save_memory()

        removed = before_count - len(self.memory["emotional_history"])
        logger.info(f"Nettoyage mÃ©moire: {removed} entrÃ©es d'historique Ã©motionnel supprimÃ©es")
        return removed

    def trim_user_phrases(self, max_phrases=500, keep_favorite=True):
        """
        Limite le nombre de phrases utilisateur stockÃ©es pour Ã©viter
        une croissance illimitÃ©e de la mÃ©moire.

        Args:
            max_phrases (int): Nombre maximum de phrases Ã  conserver
            keep_favorite (bool): Si True, conserve toutes les phrases favorites

        Returns:
            int: Nombre de phrases supprimÃ©es
        """
        if not self.memory.get("user_phrases"):
            return 0

        before_count = len(self.memory.get("user_phrases", []))

        # SÃ©parer les phrases favorites des phrases normales
        if keep_favorite:
            favorites = [p for p in self.memory.get("user_phrases", []) if p.get("is_favorite", False)]
            regulars = [p for p in self.memory.get("user_phrases", []) if not p.get("is_favorite", False)]
        else:
            favorites = []
            regulars = self.memory.get("user_phrases", [])

        # Trier les phrases normales par date (plus rÃ©centes en premier)
        regulars.sort(key=lambda x: x.get("last_seen", ""), reverse=True)

        # Limiter le nombre de phrases normales
        max_regular = max(0, max_phrases - len(favorites))
        regulars = regulars[:max_regular]

        # Recombiner les phrases
        self.memory["user_phrases"] = favorites + regulars

        # Sauvegarder les changements
        self._save_memory()

        removed = before_count - len(self.memory["user_phrases"])
        if removed > 0:
            logger.info(f"Nettoyage mÃ©moire: {removed} phrases utilisateur supprimÃ©es")

        return removed

    def optimize_memory(self):
        """
        Effectue une optimisation complÃ¨te de la mÃ©moire en:
        - Nettoyant l'historique Ã©motionnel ancien
        - Limitant le nombre de phrases utilisateur
        - Actualisant les liens affectifs

        Returns:
            dict: Statistiques de nettoyage
        """
        logger.info("DÃ©marrage de l'optimisation mÃ©moire...")
        stats = {
            "emotional_history_removed": self.cleanup_old_emotional_history(max_days=60),
            "user_phrases_removed": self.trim_user_phrases(max_phrases=300),
            "topics_cleaned": self.clean_outdated_topics(days_threshold=90),
            "timestamp": datetime.now().isoformat(),
        }

        # Force la sauvegarde des donnÃ©es nettoyÃ©es
        self._save_memory()

        logger.info(f"Optimisation mÃ©moire terminÃ©e: {stats}")
        return stats

    def get_affective_user_phrases(self, emotion: str | None = None) -> list[dict[str, Any]]:
        """
        RÃ©cupÃ¨re les phrases utilisateur Ã  contenu affectif, optionnellement filtrÃ©es par Ã©motion.

        Args:
            emotion (str, optional): L'Ã©motion spÃ©cifique Ã  rechercher

        Returns:
            List[Dict[str, Any]]: Liste des phrases affectives correspondantes
        """
        phrases = self.memory.get("user_phrases", [])

        # Filtrer d'abord par contenu affectif
        affective_phrases = [p for p in phrases if p.get("affectif", False)]

        # Si une Ã©motion est spÃ©cifiÃ©e, filtrer davantage
        if emotion:
            emotion = emotion.lower()
            filtered_phrases = []

            for phrase in affective_phrases:
                # VÃ©rifier l'Ã©motion principale
                if phrase.get("emotion", "").lower() == emotion:
                    filtered_phrases.append(phrase)
                    continue

                # VÃ©rifier dans les tags Ã©motionnels
                emotion_tags = phrase.get("emotion_tags", {})
                if emotion in emotion_tags and emotion_tags[emotion] > 0.5:
                    filtered_phrases.append(phrase)
                    continue

                # VÃ©rifier dans les tags gÃ©nÃ©raux
                if "tags" in phrase and emotion in phrase["tags"]:
                    filtered_phrases.append(phrase)
                    continue

                # Recherche dans le contenu de la phrase
                phrase_text = phrase.get("phrase", "").lower()
                emotion_keywords = {
                    "amour": ["aime", "adore", "amour", "chÃ©ri"],
                    "joie": ["content", "heureux", "heureuse", "joie", "bonheur"],
                    "nostalgie": ["manque", "souvenir", "nostalgie"],
                    "tristesse": ["triste", "peine", "dÃ©solÃ©"],
                    "surprise": ["surprise", "Ã©tonnÃ©", "stupÃ©fait"],
                    "gratitude": [
                        "merci",
                        "reconnaissance",
                        "remercie",
                        "reconnaissant",
                    ],
                }

                if emotion in emotion_keywords and any(keyword in phrase_text for keyword in emotion_keywords[emotion]):
                    filtered_phrases.append(phrase)

            return filtered_phrases

        # Sans filtre d'Ã©motion, retourner toutes les phrases affectives
        # Tri par date dÃ©croissante
        affective_phrases.sort(key=lambda x: x.get("last_seen", ""), reverse=True)

        return affective_phrases
