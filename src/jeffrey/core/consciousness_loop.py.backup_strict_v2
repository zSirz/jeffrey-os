import inspect
import importlib
import os
"""
Jeffrey OS Consciousness Loop ULTIMATE
Version finale avec toutes corrections et optimisations
"""
import asyncio
import json
import time
import re
import cProfile
import pstats
import io
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime
from pathlib import Path
from collections import deque
import sys

sys.path.insert(0, str(Path(__file__).parent.parent.parent))

class ConsciousnessLoop:
    """
    Boucle de conscience optimis√©e avec:
    - Chargement dynamique des modules
    - Cache LRU pour m√©moire
    - Extraction de noms am√©lior√©e
    - Parall√©lisation m√©moire/√©motion
    - Profiling int√©gr√©
    - Circuit breaker pour modules d√©faillants
    """

    def __init__(self, config_path: str = "artifacts/inventory_ultimate.json"):
        self.name = "Jeffrey Consciousness Loop ULTIMATE"
        self.config_path = config_path
        self.cycle_count = 0
        self.start_time = time.time()
        self.regions = {}
        self.initialized = False

        # Cache LRU pour m√©moires r√©centes
        self.memory_cache = deque(maxlen=100)

        # Profiler pour m√©triques
        self.profiler = None
        self.enable_profiling = False

        # Stats accumul√©es
        self.performance_history = deque(maxlen=50)
        self.avg_latency = 0
        self.p95_latency = 0

        # Circuit breaker pour modules d√©faillants
        self.module_failures = {}
        self.max_failures = 3

    async def initialize(self):
        """Initialiser avec chargement dynamique depuis config"""
        print("üß† Initializing Consciousness Loop ULTIMATE...")

        try:
            # Charger la configuration si elle existe
            if Path(self.config_path).exists():
                with open(self.config_path) as f:
                    config = json.load(f)
                print(f"  üìã Loaded config from {self.config_path}")
            else:
                config = {}
                print("  ‚ö†Ô∏è  No config found, using defaults")

            # 1. M√©moire persistante (Bundle 2)
            try:
                from jeffrey.bundle2.memory_integration import initialize as init_memory
                self.memory_bridge = init_memory()
                self.regions['memory'] = self.memory_bridge
                print("  ‚úÖ Memory bridge initialized")
            except ImportError as e:
                print(f"  ‚ö†Ô∏è  Memory bridge not found: {e}")
                self.memory_bridge = MemoryStub()
                self.regions['memory'] = self.memory_bridge

            # 2. Langage avec extraction de noms am√©lior√©e
            try:
                from jeffrey.bundle2.language.broca_wernicke import region_8
                self._enhance_wernicke(region_8.wernicke)
                self.language_region = region_8
                self.regions['language'] = region_8
                print("  ‚úÖ Language region enhanced and initialized")
            except ImportError:
                print("  ‚ö†Ô∏è  Language region not found, using stub")
                self.language_region = LanguageStub()
                self.regions['language'] = self.language_region

            # 3. Chargement dynamique des autres modules
            if config.get("bundle1_recommendations"):
                modules = config["bundle1_recommendations"].get("modules", [])
                for module_info in modules[:10]:
                    await self._load_module_dynamic(module_info)

            # 4. Modules critiques avec fallback
            if 'emotion' not in self.regions:
                try:
                    from jeffrey.modules.emotions.emotion_engine import EmotionEngine
                    self.emotion_core = EmotionEngine()
                    self.regions['emotion'] = self.emotion_core
                    print("  ‚úÖ Emotion engine initialized")
                except:
                    self.emotion_core = EmotionStub()
                    self.regions['emotion'] = self.emotion_core
                    print("  ‚ö†Ô∏è  Using emotion stub")

            if 'conscience' not in self.regions:
                try:
                    from icloud_vendor.consciousness.conscience_engine import ConscienceEngine
                    self.conscience_engine = ConscienceEngine()
                    self.regions['conscience'] = self.conscience_engine
                    print("  ‚úÖ Conscience engine initialized")
                except:
                    self.conscience_engine = ConscienceStub()
                    self.regions['conscience'] = self.conscience_engine
                    print("  ‚ö†Ô∏è  Using conscience stub")

            self.initialized = True
            print(f"‚úÖ Consciousness Loop ready with {len(self.regions)} regions")

            # V√©rifier qu'on n'utilise pas que des stubs
            real_modules = sum(1 for r in self.regions.values()
                             if not isinstance(r, (EmotionStub, ConscienceStub, MemoryStub, LanguageStub)))
            if real_modules < 3:
                print(f"‚ö†Ô∏è  WARNING: Only {real_modules} real modules loaded")

        except Exception as e:
            print(f"‚ùå Initialization error: {e}")
            import traceback
            traceback.print_exc()
            raise

    def _enhance_wernicke(self, wernicke):
        """Am√©liorer Wernicke avec extraction de noms FR/EN"""
        original_understand = wernicke.understand

        def enhanced_understand(text: str) -> Dict:
            result = original_understand(text)

            # Patterns d'extraction de noms am√©lior√©s
            name_patterns = [
                r"je m'appelle ([A-Za-z√Ä-√ø\-]+)",
                r"mon nom est ([A-Za-z√Ä-√ø\-]+)",
                r"my name is ([A-Za-z\-]+)",
                r"i'm ([A-Z][a-z]+)",
                r"call me ([A-Za-z\-]+)",
                r"c'est ([A-Z][a-z√Ä-√ø]+) qui"
            ]

            for pattern in name_patterns:
                matches = re.findall(pattern, text, re.IGNORECASE)
                for name in matches:
                    if len(name) > 1:
                        if 'entities' not in result:
                            result['entities'] = []
                        result['entities'].append({
                            "type": "person",
                            "value": name.capitalize()
                        })

            return result

        wernicke.understand = enhanced_understand

    async def _load_module_dynamic(self, module_info: dict):
        """Charge et INSTANCIE un module r√©el. Refuse les stubs."""
        import importlib, inspect, os, sys

        # Am√©lioration GPT: assurer le sys.path
        root = os.getcwd()
        src_dir = os.path.join(root, "src")
        if src_dir not in sys.path:
            sys.path.insert(0, src_dir)

        module_name = module_info.get("name", "")
        module_path = module_info.get("path", "")
        region = module_info.get("brain_region", "")

        if not module_path or not os.path.exists(module_path):
            print(f"  ‚ö†Ô∏è Path not found: {module_path}")
            return

        # Convertir path en import
        import_path = module_path.replace("/", ".").replace(".py", "")
        for prefix in ("src.", "."):
            if import_path.startswith(prefix):
                import_path = import_path[len(prefix):]

        # Importer le module
        mod = None
        for candidate in [import_path, f"jeffrey.{import_path.split('jeffrey.')[-1]}" if "jeffrey" in import_path else None]:
            if not candidate:
                continue
            try:
                mod = importlib.import_module(candidate)
                break
            except:
                pass

        if not mod:
            print(f"  ‚ùå Import failed: {import_path}")
            return

        # TROUVER UNE VRAIE INSTANCE
        instance = None

        # 1. Variables export√©es
        for attr in [module_name, f"{module_name}_instance", "engine", "module", "emotion_engine", "conscience_engine"]:
            if hasattr(mod, attr):
                candidate = getattr(mod, attr)
                if inspect.isclass(candidate):
                    instance = candidate()
                else:
                    instance = candidate
                break

        # 2. Classe CamelCase
        if not instance and module_name:
            camel_name = "".join(w.capitalize() for w in module_name.split("_"))
            if hasattr(mod, camel_name):
                cls = getattr(mod, camel_name)
                if inspect.isclass(cls):
                    instance = cls()

        # 3. Fonction initialize()
        if not instance and hasattr(mod, "initialize"):
            init_func = getattr(mod, "initialize")
            if inspect.iscoroutinefunction(init_func):
                instance = await init_func()
            else:
                instance = init_func()

        # 4. Chercher une classe Engine/Module
        if not instance:
            for name in dir(mod):
                obj = getattr(mod, name)
                if inspect.isclass(obj) and ("Engine" in name or "Module" in name) and "Stub" not in name:
                    try:
                        instance = obj()
                        break
                    except:
                        continue

        if not instance:
            print(f"  ‚ùå No instance found in {import_path}")
            return

        # REFUSER LES STUBS
        if "Stub" in instance.__class__.__name__:
            print(f"  ‚ùå Stub rejected for {region}")
            return

        # Initialiser si n√©cessaire
        if hasattr(instance, "initialize"):
            init = instance.initialize
            if inspect.iscoroutinefunction(init):
                await init()
            else:
                init()

        # V√âRIFIER qu'il y a une m√©thode process
        has_process = any(hasattr(instance, m) for m in ["process", "analyze", "analyze_emotion"])
        if not has_process:
            print(f"  ‚ùå No process method for {region}")
            return

        # STOCKER L'INSTANCE R√âELLE
        self.regions[region] = instance
        print(f"  ‚úÖ Loaded REAL module for {region}: {instance.__class__.__name__}")
    async def process_input(self, input_text: str, context: Dict = None) -> Dict:
        """Traiter avec parall√©lisation et optimisations"""
        if not self.initialized:
            await self.initialize()

        self.cycle_count += 1
        cycle_start = time.time()

        if self.enable_profiling:
            self.profiler = cProfile.Profile()
            self.profiler.enable()

        try:
            # 1. PERCEPTION
            perception = {
                "raw_input": input_text,
                "length": len(input_text),
                "words": input_text.split(),
                "time": 0.001
            }

            # 2. COMPR√âHENSION (avec circuit breaker)
            comprehension_start = time.time()
            try:
                if hasattr(self.language_region, 'wernicke'):
                    comprehension = self.language_region.wernicke.understand(input_text)
                else:
                    raise AttributeError("No wernicke")
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Comprehension failed: {e}, using fallback")
                comprehension = {
                    "text": input_text,
                    "intent": "unknown",
                    "entities": [],
                    "sentiment": "neutral"
                }

            comprehension["time"] = time.time() - comprehension_start

            # 3 & 4. PARALL√âLISATION M√âMOIRE + √âMOTION
            parallel_start = time.time()

            memory_task = self._process_memory(input_text, comprehension)
            emotion_task = self._process_emotion(input_text, comprehension)

            memory_result, emotion_result = await asyncio.gather(
                memory_task,
                emotion_task,
                return_exceptions=True  # Ne pas crasher si une t√¢che √©choue
            )

            # G√©rer les exceptions
            if isinstance(memory_result, Exception):
                print(f"  ‚ö†Ô∏è  Memory failed: {memory_result}")
                memory_result = {"related_memories": 0, "memories": [], "error": str(memory_result)}

            if isinstance(emotion_result, Exception):
                print(f"  ‚ö†Ô∏è  Emotion failed: {emotion_result}")
                emotion_result = {"state": {"valence": 0.5}, "error": str(emotion_result)}

            parallel_time = time.time() - parallel_start
            memory_result["time"] = parallel_time
            emotion_result["time"] = parallel_time

            # 5. CONSCIENCE
            conscience_start = time.time()

            reflection_context = {
                "comprehension": comprehension,
                "memories": memory_result,
                "emotions": emotion_result,
                "cycle": self.cycle_count
            }

            try:
                if hasattr(self.regions.get('conscience'), 'reflect'):
                    conscience_thought = self.regions['conscience'].reflect(reflection_context)
                else:
                    raise AttributeError("No reflect method")
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Conscience failed: {e}, using fallback")
                conscience_thought = {
                    "awareness": "active",
                    "confidence": 0.7,
                    "decision": "respond"
                }

            conscience_result = {
                "thought": conscience_thought,
                "time": time.time() - conscience_start
            }

            # 6. EXPRESSION
            expression_start = time.time()

            expression_context = {
                "memory_count": len(memory_result.get("memories", [])),
                "emotion": emotion_result.get("state", {}),
                "conscience": conscience_thought,
                "session_id": getattr(self.memory_bridge, 'session_id', 'unknown')[-6:]
            }

            try:
                if hasattr(self.language_region, 'broca'):
                    response_text = self.language_region.broca.generate(
                        comprehension,
                        expression_context
                    )
                else:
                    raise AttributeError("No broca")
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Expression failed: {e}, using fallback")
                response_text = "Je comprends votre message."

            expression_result = {
                "response": response_text,
                "time": time.time() - expression_start
            }

            # 7. CONSOLIDATION (async, non-bloquant)
            asyncio.create_task(
                self._consolidate_memory(
                    input_text,
                    response_text,
                    comprehension,
                    emotion_result
                )
            )

            # M√âTRIQUES
            total_time = time.time() - cycle_start
            self.performance_history.append(total_time * 1000)

            if len(self.performance_history) > 10:
                sorted_times = sorted(self.performance_history)
                self.p95_latency = sorted_times[int(len(sorted_times) * 0.95)]
                self.avg_latency = sum(sorted_times) / len(sorted_times)

            if self.profiler:
                self.profiler.disable()

            return {
                "success": True,
                "cycle": self.cycle_count,
                "response": response_text,
                "comprehension": comprehension,
                "memory": memory_result,
                "emotion": emotion_result,
                "conscience": conscience_result,
                "performance": {
                    "total_time_ms": total_time * 1000,
                    "perception_ms": 0.001 * 1000,
                    "comprehension_ms": comprehension.get("time", 0) * 1000,
                    "memory_emotion_parallel_ms": parallel_time * 1000,
                    "conscience_ms": conscience_result["time"] * 1000,
                    "expression_ms": expression_result["time"] * 1000,
                    "avg_latency_ms": self.avg_latency,
                    "p95_latency_ms": self.p95_latency
                }
            }

        except Exception as e:
            print(f"‚ùå Error in consciousness loop: {e}")
            if self.profiler:
                self.profiler.disable()

            return {
                "success": False,
                "error": str(e),
                "cycle": self.cycle_count,
                "response": "Une erreur s'est produite. R√©essayons."
            }

    async def _process_memory(self, input_text: str, comprehension: Dict) -> Dict:
        """Traitement m√©moire avec cache et extraction intelligente"""
        try:
            # V√©rifier le cache
            cache_hit = self._check_memory_cache(input_text)
            if cache_hit:
                return {
                    "related_memories": len(cache_hit),
                    "memories": cache_hit,
                    "from_cache": True
                }

            # Extraction intelligente des mots-cl√©s (FIX GPT #1)
            entities = comprehension.get("entities", [])
            keywords = []

            for entity in entities:
                if isinstance(entity, dict):
                    value = entity.get("value", "")
                else:
                    value = str(entity)
                if value:
                    keywords.append(value)

            if not keywords:
                words = input_text.split()
                keywords = [w for w in words if len(w) > 3][:3]

            search_query = " ".join(keywords[:3]) if keywords else input_text[:40]

            # Rechercher
            if hasattr(self.memory_bridge, 'store'):
                related = await self.memory_bridge.store.search(search_query, limit=5)
                session = await self.memory_bridge.get_context(limit=3)
            else:
                related = []
                session = []

            # Mettre en cache
            result_memories = related[:3]
            if result_memories:
                self.memory_cache.extend(result_memories)

            return {
                "related_memories": len(related),
                "session_context": len(session),
                "memories": result_memories,
                "keywords_used": keywords[:3],
                "from_cache": False
            }

        except Exception as e:
            raise Exception(f"Memory error: {e}")

    async def _process_emotion(self, input_text: str, comprehension: Dict) -> Dict:
        """Traitement √©motionnel avec fallback"""
        try:
            context = {
                "sentiment": comprehension.get("sentiment", "neutral"),
                "intent": comprehension.get("intent", "unknown")
            }

            emotion_module = self.regions.get('emotion')
            if hasattr(emotion_module, 'process'):
                state = emotion_module.process(input_text, context)
            elif hasattr(emotion_module, 'analyze'):
                state = emotion_module.analyze(context)
            else:
                state = {"valence": 0.5, "arousal": 0.5}

            return {"state": state}

        except Exception as e:
            raise Exception(f"Emotion error: {e}")

    async def _consolidate_memory(self, input_text: str, response: str,
                                 comprehension: Dict, emotion: Dict):
        """Consolidation m√©moire asynchrone"""
        try:
            if not hasattr(self.memory_bridge, 'store'):
                return

            metadata = {
                "context": {
                    "cycle": self.cycle_count,
                    "intent": comprehension.get("intent"),
                    "entities": comprehension.get("entities", []),
                    "session_id": getattr(self.memory_bridge, 'session_id', 'unknown')
                },
                "emotions": emotion.get("state", {}),
                "importance": 0.5
            }

            input_id = await self.memory_bridge.store.store(input_text,
                                                           {**metadata, "source": "user"})
            response_id = await self.memory_bridge.store.store(response,
                                                              {**metadata, "source": "jeffrey",
                                                               "reply_to": input_id})

        except Exception as e:
            print(f"  ‚ö†Ô∏è  Consolidation error: {e}")

    def _check_memory_cache(self, query: str) -> Optional[List]:
        """V√©rifier le cache m√©moire LRU"""
        results = []
        query_lower = query.lower()

        for memory in self.memory_cache:
            if isinstance(memory, dict):
                content = str(memory.get("content", "")).lower()
                if any(word in content for word in query_lower.split()):
                    results.append(memory)
                    if len(results) >= 3:
                        break

        return results if results else None

    def get_profiling_stats(self) -> str:
        """Obtenir les stats de profiling"""
        if not self.profiler:
            return "Profiling not enabled"

        s = io.StringIO()
        ps = pstats.Stats(self.profiler, stream=s)
        ps.strip_dirs()
        ps.sort_stats('cumulative')
        ps.print_stats(10)
        return s.getvalue()

    def health_check(self) -> Dict:
        """Health check avec d√©tection de stubs et failures"""
        try:
            uptime = time.time() - self.start_time

            regions_health = {}
            stub_count = 0

            for name, region in self.regions.items():
                is_stub = isinstance(region, (EmotionStub, ConscienceStub,
                                             MemoryStub, LanguageStub))

                if hasattr(region, 'health_check'):
                    health = region.health_check()
                else:
                    health = {"status": "unknown"}

                health["is_stub"] = is_stub
                if is_stub:
                    stub_count += 1

                regions_health[name] = health

            return {
                "status": "healthy" if self.initialized else "not_initialized",
                "module": __name__,
                "uptime_seconds": uptime,
                "cycles_completed": self.cycle_count,
                "regions_active": len(self.regions),
                "real_modules": len(self.regions) - stub_count,
                "stub_modules": stub_count,
                "module_failures": dict(self.module_failures),
                "regions_health": regions_health,
                "performance": {
                    "avg_latency_ms": self.avg_latency,
                    "p95_latency_ms": self.p95_latency,
                    "cache_size": len(self.memory_cache)
                }
            }
        except Exception as e:
            return {
                "status": "unhealthy",
                "module": __name__,
                "error": str(e)
            }


# ============================================
# STUBS AM√âLIOR√âS (avec MemoryStub corrig√©)
# ============================================

class EmotionStub:
    def analyze(self, context):
        sentiment = context.get("sentiment", "neutral")
        valence = 0.8 if sentiment == "positive" else (0.2 if sentiment == "negative" else 0.5)
        return {"valence": valence, "arousal": 0.5, "dominance": 0.5, "primary": sentiment}

    def process(self, text, context):
        return self.analyze(context)

    def health_check(self):
        return {"status": "stub", "module": "EmotionStub"}

class ConscienceStub:
    def reflect(self, context):
        emotions = context.get("emotions", {})
        confidence = 0.9 if emotions.get("state", {}).get("valence", 0.5) > 0.6 else 0.6
        return {
            "awareness": "active",
            "self_model": "stable",
            "decision": "respond",
            "confidence": confidence,
            "ethical_alignment": 1.0
        }

    def health_check(self):
        return {"status": "stub", "module": "ConscienceStub"}

class MemoryStub:
    """Stub m√©moire compatible avec l'interface memory_integration (has .store.{store,search})"""
    def __init__(self):
        self.memories = []
        self.session_id = f"stub_{int(time.time())}"

        class _Store:
            def __init__(self, parent):
                self.parent = parent
            async def store(self, content, metadata=None):
                mid = f"mem_{len(self.parent.memories)}"
                self.parent.memories.append(
                    {"id": mid, "content": content, "context": (metadata or {}).get("context", {})}
                )
                return mid
            async def search(self, query, limit=5):
                return self.parent.memories[-limit:]

        self.store = _Store(self)

    async def get_context(self, limit=5):
        return self.memories[-limit:]

    def health_check(self):
        return {"status": "stub", "module": "MemoryStub"}

class LanguageStub:
    def __init__(self):
        self.wernicke = WernickeStub()
        self.broca = BrocaStub()

    def health_check(self):
        return {"status": "stub", "module": "LanguageStub"}

class WernickeStub:
    def understand(self, text):
        return {
            "text": text,
            "intent": "greeting" if any(g in text.lower() for g in ["bonjour", "hello", "salut"]) else "unknown",
            "entities": [],
            "sentiment": "neutral"
        }

class BrocaStub:
    def generate(self, understanding, context):
        return "Message re√ßu et compris."

# Instance globale
consciousness_loop = None

def initialize():
    global consciousness_loop
    consciousness_loop = ConsciousnessLoop()
    return consciousness_loop

def health_check():
    if consciousness_loop:
        return consciousness_loop.health_check()
    return {"status": "not_initialized", "module": __name__}
