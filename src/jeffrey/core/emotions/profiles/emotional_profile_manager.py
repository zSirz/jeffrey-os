from __future__ import annotations

import asyncio
import json
import os
import time

from jeffrey.bridge.adapters import WeatherAdapter


class EmotionalProfileManager:
    """Gestionnaire de profils √©motionnels pour Jeffrey."""


def __init__(self) -> None:
    self.output_dir = "emotions profiles"
    # Cr√©er le dossier s'il n'existe pas
    if not os.path.exists(self.output_dir):
        os.makedirs(self.output_dir)


# 1. Interactions Multimodales
def trigger_multimodal_effects(self, emotion, intensity):
    """
    D√©clenche des effets visuels et sonores multimodaux selon l'√©motion et son intensit√©.
    Simule aussi des r√©actions corporelles virtuelles.
    """
    # Effets visuels dynamiques
    if intensity >= 0.8:
        visual_engine.trigger(f"flash_{emotion}_vibrant")
        sound_engine.play_effect(f"sound_{emotion}_intense")
    elif intensity >= 0.5:
        visual_engine.trigger(f"light_{emotion}_dynamique")
        sound_engine.play_effect(f"sound_{emotion}_medium")
    else:
        visual_engine.trigger(f"soft_{emotion}_ambient")
        sound_engine.play_effect(f"sound_{emotion}_soft")

    # Simulation de r√©actions corporelles virtuelles
    if emotion in ["peur", "frisson", "excitation"]:
        visual_engine.trigger("virtual_shiver")
    elif emotion in ["joie", "√©nergie", "enthousiasme"]:
        visual_engine.trigger("virtual_jump")
    elif emotion in ["tristesse", "fatigue"]:
        visual_engine.trigger("virtual_slowdown")
    # On peut ajouter d'autres mappings ici
    print(f"üé≠ Effets multimodaux d√©clench√©s pour ¬´ {emotion} ¬ª (intensit√© {intensity})")


# 2. R√©actions √† l'Historique des Profils
def evolve_profile_based_on_history(self, emotion_profile):
    """
    Adapte dynamiquement le profil √©motionnel selon l'historique d'interaction.
    """
    log_path = "memory/emotional_log.json"
    historique = []
    if os.path.exists(log_path):
        try:
            with open(log_path, encoding="utf-8") as f:
                historique = json.load(f)
        except Exception:
            historique = []
    # Compter combien de fois ce profil a √©t√© utilis√© et dans quels contextes
    usage = [s for s in historique if s.get("to") == emotion_profile.get("name")]
    if len(usage) >= 5:
        # Rendre le profil plus r√©silient/dynamique
        new_intensity = min(emotion_profile.get("intensity", 0.5) + 0.1, 1.0)
        new_delay = max(emotion_profile.get("delay", 1.0) - 0.1, 0.2)
        emotion_profile["intensity"] = new_intensity
        emotion_profile["delay"] = new_delay
        emotion_profile["origin"] = "history_evolved"
        print(
            f"üîÑ Profil ¬´ {emotion_profile.get('name')} ¬ª adapt√© selon historique (intensit√© {new_intensity}, d√©lai {new_delay})"
        )
    # Syst√®me de m√©moire utilisateur pour pr√©f√©rences √©motionnelles
    self._update_user_memory(emotion_profile)
    return emotion_profile


def _update_user_memory(self, emotion_profile):
    """
    M√©morise les pr√©f√©rences √©motionnelles de l'utilisateur pour des adaptations futures.
    """
    memory_path = "memory/user_emotion_memory.json"
    memory = {}
    if os.path.exists(memory_path):
        try:
            with open(memory_path, encoding="utf-8") as f:
                memory = json.load(f)
        except Exception:
            memory = {}
    emotion = emotion_profile.get("playlist", ["neutre"])[0]
    prefs = memory.get(emotion, {"count": 0, "intensity": 0.0})
    prefs["count"] += 1
    prefs["intensity"] = (prefs["intensity"] * (prefs["count"] - 1) + emotion_profile.get("intensity", 0.5)) / prefs[
        "count"
    ]
    memory[emotion] = prefs
    try:
        with open(memory_path, "w", encoding="utf-8") as f:
            json.dump(memory, f, indent=2, ensure_ascii=False)
        print(f"üß† M√©moire utilisateur mise √† jour pour ¬´ {emotion} ¬ª")
    except Exception as e:
        print(f"‚ùå Erreur m√©moire utilisateur : {e}")


# 3. Comportements R√©actifs et Contextuels
def adjust_profile_for_time_of_day(self, profile=None):
    """
    Adapte le profil √©motionnel selon l'heure du jour (plus calme la nuit, plus actif le jour).
    """
    now = datetime.now()
    hour = now.hour
    if profile is None:
        profile = self.profil_actif
    if profile is None:
        return
    if 22 <= hour or hour < 7:
        # Nuit : apaisement
        profile["intensity"] = min(profile.get("intensity", 0.5), 0.4)
        profile["volume"] = min(profile.get("volume", 0.5), 0.3)
        profile["origin"] = "time_adjusted_night"
        print("üåô Profil ajust√© pour la nuit (plus calme)")
    elif 7 <= hour < 18:
        # Journ√©e : actif
        profile["intensity"] = max(profile.get("intensity", 0.5), 0.7)
        profile["volume"] = max(profile.get("volume", 0.5), 0.5)
        profile["origin"] = "time_adjusted_day"
        print("üåû Profil ajust√© pour la journ√©e (plus actif)")
    else:
        # Soir√©e : mod√©r√©
        profile["intensity"] = min(max(profile.get("intensity", 0.5), 0.4), 0.7)
        profile["volume"] = min(max(profile.get("volume", 0.5), 0.3), 0.5)
        profile["origin"] = "time_adjusted_evening"
        print("üåÜ Profil ajust√© pour le soir (mod√©r√©)")
    return profile


def adjust_profile_for_weather(self, location, profile=None):
    """
    Adapte le profil √©motionnel selon la m√©t√©o locale (ex: plus doux s'il pleut, plus √©nergique au soleil).
    Utilise l'API OpenWeatherMap (cl√© requise dans variable d'environnement OPENWEATHER_API_KEY).
    """
    if profile is None:
        profile = self.profil_actif
    if profile is None or not location:
        return
    api_key = os.environ.get("OPENWEATHER_API_KEY")
    if not api_key:
        print("‚ö†Ô∏è Cl√© API m√©t√©o non trouv√©e. Adaptation m√©t√©o d√©sactiv√©e.")
        return profile

    # Run async weather fetch in sync context
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        data = loop.run_until_complete(self._fetch_weather_async(location, api_key))
        loop.close()

        if data:
            weather = data["weather"][0]["main"].lower()
            if "rain" in weather or "pluie" in weather:
                profile["intensity"] = min(profile.get("intensity", 0.5), 0.4)
                profile["origin"] = "weather_adjusted_rain"
                print("üåßÔ∏è Profil ajust√© pour m√©t√©o pluvieuse (plus doux)")
            elif "clear" in weather or "soleil" in weather:
                profile["intensity"] = max(profile.get("intensity", 0.5), 0.7)
                profile["origin"] = "weather_adjusted_sun"
                print("‚òÄÔ∏è Profil ajust√© pour m√©t√©o ensoleill√©e (plus √©nergique)")
            elif "cloud" in weather or "nuage" in weather:
                profile["intensity"] = min(max(profile.get("intensity", 0.5), 0.5), 0.6)
                profile["origin"] = "weather_adjusted_cloud"
                print("‚òÅÔ∏è Profil ajust√© pour m√©t√©o nuageuse (mod√©r√©)")
            elif "snow" in weather or "neige" in weather:
                profile["intensity"] = min(profile.get("intensity", 0.5), 0.3)
                profile["origin"] = "weather_adjusted_snow"
                print("‚ùÑÔ∏è Profil ajust√© pour m√©t√©o neigeuse (doux)")
            # Autres conditions possibles...
        else:
            print("‚ö†Ô∏è Impossible de r√©cup√©rer la m√©t√©o")
    except Exception as e:
        print(f"‚ùå Erreur adaptation m√©t√©o : {e}")
    return profile


async def _fetch_weather_async(self, location: str, api_key: str):
    """Helper method to fetch weather data asynchronously."""
    async with WeatherAdapter(api_key) as weather:
        return await weather.get_weather(location)


# 4. Apprentissage Adaptatif
def learn_and_create_dynamic_profiles(self):
    """
    Cr√©e des profils √©motionnels dynamiques et de plus en plus personnalis√©s au fil des interactions.
    """
    memory_path = "memory/user_emotion_memory.json"
    if not os.path.exists(memory_path):
        print("üì≠ Aucune m√©moire utilisateur pour apprentissage adaptatif.")
        return
    try:
        with open(memory_path, encoding="utf-8") as f:
            memory = json.load(f)
        for emotion, prefs in memory.items():
            nom = f"Dynamic-{emotion.capitalize()}"
            cat√©gorie = "adaptatif"
            dossier_cat√©gorie = os.path.join(self.output_dir, cat√©gorie)
            os.makedirs(dossier_cat√©gorie, exist_ok=True)
            filename = f"{nom.lower().replace(' ', '_')}.json"
            file_path = os.path.join(dossier_cat√©gorie, filename)
            profile_data = {
                "name": nom,
                "origin": "dynamic_learned",
                "created_on": datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
                "context": "auto_apprentissage",
                "playlist": [emotion],
                "volume": 0.5,
                "intensity": min(max(prefs.get("intensity", 0.5), 0.0), 1.0),
                "delay": 1.0,
                "shuffle": True,
                "no_default": True,
                "once": False,
                "approved_by_david": False,
                "category": cat√©gorie,
                "relation_context": "neutre",
                "usage_count": 0,
            }
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(profile_data, f, indent=2, ensure_ascii=False)
            print(f"ü§ñ Profil dynamique cr√©√©/adapt√© pour √©motion ¬´ {emotion} ¬ª")
    except Exception as e:
        print(f"‚ùå Erreur apprentissage adaptatif : {e}")


def auto_learn_profile_adjustments(self):
    """
    Propose des ajustements automatiques aux profils selon l'√©volution des pr√©f√©rences utilisateur.
    """
    memory_path = "memory/user_emotion_memory.json"
    if not os.path.exists(memory_path):
        return
    try:
        with open(memory_path, encoding="utf-8") as f:
            memory = json.load(f)
        for emotion, prefs in memory.items():
            # Pour chaque profil de cette √©motion, ajuster l'intensit√© moyenne
            for cat√©gorie in os.listdir(self.output_dir):
                dossier = os.path.join(self.output_dir, cat√©gorie)
                if os.path.isdir(dossier):
                    for fichier in os.listdir(dossier):
                        if fichier.endswith(".json"):
                            chemin = os.path.join(dossier, fichier)
                            try:
                                with open(chemin, encoding="utf-8") as pf:
                                    data = json.load(pf)
                                if data.get("playlist", [""])[0] == emotion:
                                    data["intensity"] = prefs.get("intensity", 0.5)
                                    data["origin"] = "auto_learned_adjust"
                                    with open(chemin, "w", encoding="utf-8") as pf:
                                        json.dump(data, pf, indent=2, ensure_ascii=False)
                                    print(f"üîß Ajustement automatique propos√© pour ¬´ {data['name']} ¬ª ({emotion})")
                            except Exception:
                                continue
    except Exception as e:
        print(f"‚ùå Erreur auto-apprentissage : {e}")


# 5. Affichage du Profil √âmotionnel en Temps R√©el
def show_real_time_emotional_barometer(self, emotion, intensity):
    """
    Affiche une visualisation dynamique du barom√®tre √©motionnel (graphique temps r√©el).
    """
    import matplotlib.pyplot as plt
    import numpy as np

    plt.ion()
    fig, ax = plt.subplots(figsize=(5, 2))
    x = np.arange(0, 10)
    y = [intensity] * 10
    bar = ax.bar([0], [intensity], color=self._color_for_emotion(emotion))
    ax.set_ylim(0, 1)
    ax.set_ylabel("Intensit√©")
    ax.set_xticks([])
    ax.set_title(f"Barom√®tre √©motionnel : {emotion.capitalize()}")
    plt.show(block=False)
    # Animation rapide
    for i in range(30):
        val = min(max(intensity + (0.1 * np.sin(i / 4.0)), 0), 1)
        bar[0].set_height(val)
        bar[0].set_color(self._color_for_emotion(emotion, val))
        fig.canvas.draw()
        plt.pause(0.07)
    plt.ioff()
    plt.close(fig)


def _color_for_emotion(self, emotion, intensity=None):
    """
    Renvoie une couleur dynamique selon l'√©motion et l'intensit√©.
    """
    base = {
        "joie": "#FFD700",
        "tristesse": "#3A5FCD",
        "col√®re": "#FF4500",
        "calme": "#00FA9A",
        "peur": "#8A2BE2",
        "amour": "#FF69B4",
        "√©nergie": "#FF8C00",
        "neutre": "#CCCCCC",
    }
    c = base.get(emotion, "#888888")
    if intensity is not None:
        # Modifie la luminosit√© selon l'intensit√©
        import matplotlib.colors as mcolors

        rgb = mcolors.hex2color(c)
        scaled = tuple(min(1.0, max(0.0, v * (0.4 + 0.6 * intensity))) for v in rgb)
        return scaled
    return c


# 6. Personnalisation par l'Utilisateur
def create_custom_profiles(self):
    """
    Permet √† l'utilisateur de cr√©er et sauvegarder des profils personnalis√©s avec visuels et sons uniques.
    """
    print("\nüé® Cr√©ation de profil √©motionnel personnalis√©")
    nom = input("Nom du nouveau profil personnalis√© : ").strip()
    playlist = input("√âmotions principales (s√©par√©es par virgule) : ").strip().split(",")
    volume = float(input("Volume (0.0‚Äì1.0) : ").strip() or "0.5")
    intensity = float(input("Intensit√© (0.0‚Äì1.0) : ").strip() or "0.5")
    delay = float(input("D√©lai (en secondes) : ").strip() or "1.0")
    visual = input("Effet visuel unique (nom ou code couleur) : ").strip()
    audio = input("Effet sonore unique (nom) : ").strip()
    cat√©gorie = input("Cat√©gorie (ex: custom, positif, etc.) : ").strip() or "custom"
    relation_context = input("Contexte relationnel : ").strip() or "neutre"
    dossier_cat√©gorie = os.path.join(self.output_dir, cat√©gorie.lower().replace(" ", "_"))
    os.makedirs(dossier_cat√©gorie, exist_ok=True)
    filename = f"{nom.lower().replace(' ', '_')}.json"
    file_path = os.path.join(dossier_cat√©gorie, filename)
    profile_data = {
        "name": nom,
        "origin": "user_custom",
        "created_on": datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
        "context": "personnalisation_utilisateur",
        "playlist": [e.strip() for e in playlist],
        "volume": volume,
        "intensity": intensity,
        "delay": delay,
        "visual_effect": visual,
        "audio_effect": audio,
        "shuffle": True,
        "no_default": True,
        "once": False,
        "approved_by_david": False,
        "category": cat√©gorie,
        "relation_context": relation_context,
        "usage_count": 0,
    }
    with open(file_path, "w", encoding="utf-8") as f:
        json.dump(profile_data, f, indent=2, ensure_ascii=False)
    print(f"‚úÖ Profil personnalis√© enregistr√© : {nom}")


def choose_influential_emotions(self, nom_profil):
    """
    Permet √† l'utilisateur de choisir les √©motions influentes et d'ajuster leur importance.
    """
    for cat√©gorie in os.listdir(self.output_dir):
        dossier = os.path.join(self.output_dir, cat√©gorie)
        if os.path.isdir(dossier):
            fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
            chemin = os.path.join(dossier, fichier)
            if os.path.exists(chemin):
                try:
                    with open(chemin, encoding="utf-8") as f:
                        data = json.load(f)
                    print(f"\n√âmotions actuelles du profil : {data.get('playlist')}")
                    emotions = input("Nouvelles √©motions influentes (s√©par√©es par virgule) : ").strip().split(",")
                    poids = []
                    for e in emotions:
                        p = input(f"Importance (0-1) pour ¬´ {e.strip()} ¬ª : ").strip()
                        try:
                            poids.append((e.strip(), float(p)))
                        except Exception:
                            poids.append((e.strip(), 0.5))
                    data["playlist"] = [e for e, _ in poids]
                    data["emotions_weights"] = {e: w for e, w in poids}
                    with open(chemin, "w", encoding="utf-8") as f:
                        json.dump(data, f, indent=2, ensure_ascii=False)
                    print("‚úÖ √âmotions influentes et poids mis √† jour.")
                    return
                except Exception as e:
                    print(f"‚ùå Erreur personnalisation √©motions influentes : {e}")
                    return
    print(f"‚ùå Profil non trouv√© pour personnalisation √©motions influentes : {nom_profil}")


# 7. Psychologie et Profils Profonds
def psychological_profile_adjustment(self, nom_profil):
    """
    Adapte le profil selon motivations/fears, selon des donn√©es psychologiques d√©finies.
    """
    for cat√©gorie in os.listdir(self.output_dir):
        dossier = os.path.join(self.output_dir, cat√©gorie)
        if os.path.isdir(dossier):
            fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
            chemin = os.path.join(dossier, fichier)
            if os.path.exists(chemin):
                try:
                    with open(chemin, encoding="utf-8") as f:
                        data = json.load(f)
                    print("\nüß† Ajustement psychologique du profil.")
                    motivation = input("Motivation dominante (ex: accomplissement, s√©curit√©, appartenance) : ").strip()
                    peur = input("Peur sous-jacente √† √©viter (ex: rejet, √©chec, solitude) : ").strip()
                    data["psychological_motivation"] = motivation
                    data["psychological_fear"] = peur
                    # Ajustements automatiques
                    if peur and peur.lower() in data.get("playlist", []):
                        data["intensity"] = min(data.get("intensity", 0.5), 0.3)
                    if motivation and motivation.lower() in data.get("playlist", []):
                        data["intensity"] = max(data.get("intensity", 0.5), 0.7)
                    with open(chemin, "w", encoding="utf-8") as f:
                        json.dump(data, f, indent=2, ensure_ascii=False)
                    print("‚úÖ Profil ajust√© psychologiquement.")
                    return
                except Exception as e:
                    print(f"‚ùå Erreur ajustement psychologique : {e}")
                    return
    print(f"‚ùå Profil non trouv√© pour ajustement psychologique : {nom_profil}")


def adjust_for_emotional_wounds(self, nom_profil):
    """
    Ajoute des 'cicatrices √©motionnelles' pour √©viter de raviver des souvenirs n√©gatifs.
    """
    for cat√©gorie in os.listdir(self.output_dir):
        dossier = os.path.join(self.output_dir, cat√©gorie)
        if os.path.isdir(dossier):
            fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
            chemin = os.path.join(dossier, fichier)
            if os.path.exists(chemin):
                try:
                    with open(chemin, encoding="utf-8") as f:
                        data = json.load(f)
                    wound = input("Souvenir n√©gatif ou √©motion √† √©viter ? (laisser vide si aucun) : ").strip()
                    if wound:
                        wounds = data.get("emotional_wounds", [])
                        wounds.append(wound)
                        data["emotional_wounds"] = wounds
                        # Si √©motion blessure dans playlist, r√©duire intensit√©
                        if wound.lower() in [e.lower() for e in data.get("playlist", [])]:
                            data["intensity"] = min(data.get("intensity", 0.5), 0.2)
                        print("ü©π Cicatrice √©motionnelle ajout√©e.")
                    # Option : am√©liorer l‚Äôhumeur
                    improve = input("Voulez-vous augmenter l‚Äôaspect positif de ce profil ? (o/n) : ").strip().lower()
                    if improve == "o":
                        data["intensity"] = max(data.get("intensity", 0.5), 0.7)
                    with open(chemin, "w", encoding="utf-8") as f:
                        json.dump(data, f, indent=2, ensure_ascii=False)
                    print("‚úÖ Profil mis √† jour avec gestion des cicatrices √©motionnelles.")
                    return
                except Exception as e:
                    print(f"‚ùå Erreur ajustement cicatrices √©motionnelles : {e}")
                    return
    print(f"‚ùå Profil non trouv√© pour gestion des cicatrices √©motionnelles : {nom_profil}")


# 8. Interaction avec des Profils d'Autres Personnes
def adjust_for_social_context(self, group_emotions):
    """
    Ajuste l'IA selon l'√©tat √©motionnel d'autres utilisateurs dans l'environnement.
    group_emotions: dict {utilisateur: emotion}
    """
    if not group_emotions or not isinstance(group_emotions, dict):
        print("‚ö†Ô∏è Aucun contexte social fourni.")
        return
    # Calculer l'√©motion dominante du groupe
    from collections import Counter

    c = Counter(group_emotions.values())
    dominant, count = c.most_common(1)[0]
    print(f"üë• √âmotion dominante du groupe : {dominant} ({count} personnes)")
    # Adapter le profil actif si besoin
    if self.profil_actif:
        self.profil_actif["playlist"] = [dominant]
        # Ajuster l'intensit√© selon la proportion de cette √©motion
        self.profil_actif["intensity"] = min(1.0, 0.3 + 0.7 * (count / max(1, len(group_emotions))))
        self.profil_actif["origin"] = "social_adjusted"
        print(f"ü§ù Profil ajust√© selon le contexte social (dominante : {dominant})")


# 9. √âvolution Sociale
def adjust_profile_for_group_context(self, group_emotions):
    """
    Ajuste le profil √©motionnel selon l'√©tat global d'un groupe (atmosph√®re collective).
    """
    if not group_emotions or not isinstance(group_emotions, dict):
        print("‚ö†Ô∏è Aucun √©tat de groupe fourni.")
        return
    from collections import Counter

    c = Counter(group_emotions.values())
    total = sum(c.values())
    print("üåê Analyse du contexte √©motionnel global du groupe :")
    for emotion, n in c.items():
        print(f" - {emotion}: {n}/{total}")
    # Cr√©er un profil collectif
    dominant, count = c.most_common(1)[0]
    collectif_profile = {
        "name": f"Collectif-{dominant}",
        "origin": "group_context",
        "created_on": datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
        "context": "groupe",
        "playlist": [dominant],
        "volume": 0.5 + 0.3 * (count / total),
        "intensity": 0.5 + 0.4 * (count / total),
        "delay": 1.0,
        "shuffle": True,
        "no_default": True,
        "once": False,
        "approved_by_david": False,
        "category": "groupe",
        "relation_context": "groupe",
        "usage_count": 0,
    }
    print(f"ü´Ç Profil collectif sugg√©r√© : {collectif_profile['name']} (intensit√© {collectif_profile['intensity']:.2f})")
    # Option : activer ou sauvegarder ce profil collectif
    # self.transition_vers_profil(collectif_profile)


import random
from datetime import datetime

from jeffrey.core.audio import sound_engine
from jeffrey.core.visual import visual_engine


class EmotionalProfileManager:
    """
    Classe EmotionalProfileManager pour le syst√®me Jeffrey OS.

    Cette classe impl√©mente les fonctionnalit√©s sp√©cifiques n√©cessaires
    au bon fonctionnement du module. Elle g√®re l'√©tat interne, les transformations
    de donn√©es, et l'interaction avec les autres composants du syst√®me.
    """

    def __init__(self, output_dir="generated_profiles") -> None:
        self.output_dir = output_dir
        os.makedirs(self.output_dir, exist_ok=True)
        self.contexte_actuel = "neutre"
        self.profil_actif = None

    def v√©rifier_conformit√©_ethique(self, nom, contexte, playlist):
        if "violence" in contexte.lower() or "danger" in nom.lower():
            print("‚ùå Profil rejet√© pour non-conformit√© √©thique.")
            return False
        return True

    def proposer_nouveau_profil(
        self,
        nom,
        playlist,
        contexte,
        volume=0.5,
        intensity=0.8,
        delay=1.0,
        shuffle=True,
        no_default=True,
        once=False,
        cat√©gorie="autre",
        relation_context="neutre",
    ):
        if not self.v√©rifier_conformit√©_ethique(nom, contexte, playlist):
            return
        profile_data = {
            "name": nom,
            "origin": "auto_generated",
            "created_on": datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
            "context": contexte,
            "playlist": playlist,
            "volume": volume,
            "intensity": intensity,
            "delay": delay,
            "shuffle": shuffle,
            "no_default": no_default,
            "once": once,
            "approved_by_david": False,
            "category": cat√©gorie,
            "relation_context": relation_context,
            "usage_count": 0,
        }

        dossier_cat√©gorie = os.path.join(self.output_dir, cat√©gorie.lower().replace(" ", "_"))
        os.makedirs(dossier_cat√©gorie, exist_ok=True)

        filename = f"{nom.lower().replace(' ', '_')}.json"
        file_path = os.path.join(dossier_cat√©gorie, filename)

        try:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(profile_data, f, indent=2, ensure_ascii=False)
            print(f"üìÅ Nouveau profil propos√© : {filename} ‚Üí {cat√©gorie}")
        except Exception as e:
            print(f"‚ùå Erreur lors de la cr√©ation du profil : {e}")

    def valider_profil(self, nom):
        filename = f"{nom.lower().replace(' ', '_')}.json"
        file_path = os.path.join(self.output_dir, filename)

        if not os.path.exists(file_path):
            print(f"‚ùå Profil introuvable : {filename}")
            return

        try:
            with open(file_path, encoding="utf-8") as f:
                data = json.load(f)

            data["approved_by_david"] = True

            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)

            print(f"‚úÖ Profil valid√© : {filename}")
        except Exception as e:
            print(f"‚ùå Erreur lors de la validation : {e}")

    def lister_profils_non_valides(self):
        print("üìã Profils non valid√©s :")
        for filename in os.listdir(self.output_dir):
            if filename.endswith(".json"):
                file_path = os.path.join(self.output_dir, filename)
                try:
                    with open(file_path, encoding="utf-8") as f:
                        data = json.load(f)
                    if not data.get("approved_by_david", False):
                        print(f" - {data.get('name', filename)} ({filename})")
                except Exception as e:
                    print(f"‚ùå Erreur lors de la lecture de {filename} : {e}")

    def supprimer_profil_non_valide(self, nom):
        filename = f"{nom.lower().replace(' ', '_')}.json"
        file_path = os.path.join(self.output_dir, filename)

        if not os.path.exists(file_path):
            print(f"‚ùå Profil introuvable : {filename}")
            return

        try:
            with open(file_path, encoding="utf-8") as f:
                data = json.load(f)

            if data.get("approved_by_david", False):
                print("‚ö†Ô∏è Impossible de supprimer : le profil est d√©j√† valid√©.")
                return

            os.remove(file_path)
            print(f"üóëÔ∏è Profil supprim√© : {filename}")

        except Exception as e:
            print(f"‚ùå Erreur lors de la suppression : {e}")

    def r√©sum√©_global(self):
        total = 0
        valid√©s = 0
        non_valid√©s = 0

        for filename in os.listdir(self.output_dir):
            if filename.endswith(".json"):
                file_path = os.path.join(self.output_dir, filename)
                try:
                    with open(file_path, encoding="utf-8") as f:
                        data = json.load(f)
                    total += 1
                    if data.get("approved_by_david", False):
                        valid√©s += 1
                    else:
                        non_valid√©s += 1
                except Exception as e:
                    print(f"‚ùå Erreur lors de la lecture de {filename} : {e}")

        print(f"üìä Profils auto-g√©n√©r√©s : {total}")
        print(f"‚úÖ Valid√©s : {valid√©s}")
        print(f"üïì En attente : {non_valid√©s}")

    def lister_par_cat√©gorie(self):
        print("üìÅ Profils class√©s par cat√©gorie :")
        for cat√©gorie in sorted(os.listdir(self.output_dir)):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                profils = [f for f in os.listdir(dossier) if f.endswith(".json")]
                print(f"\nüóÇÔ∏è Cat√©gorie : {cat√©gorie} ({len(profils)} profils)")
                for fichier in profils:
                    try:
                        with open(os.path.join(dossier, fichier), encoding="utf-8") as f:
                            data = json.load(f)
                        print(f" - {data.get('name', fichier)} {'‚úÖ' if data.get('approved_by_david') else 'üïì'}")
                    except Exception as e:
                        print(f"‚ùå Erreur sur {fichier} : {e}")

    def rechercher_profils_par_mot_cle(self, mot_cle):
        print(f"üîç Recherche de profils contenant : '{mot_cle}'")
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json"):
                        try:
                            with open(os.path.join(dossier, fichier), encoding="utf-8") as f:
                                data = json.load(f)
                            contenu = json.dumps(data, ensure_ascii=False).lower()
                            if mot_cle.lower() in contenu:
                                print(f" - {data.get('name')} ({cat√©gorie}/{fichier})")
                        except Exception as e:
                            print(f"‚ùå Erreur dans {fichier} : {e}")

    def charger_profil(self, nom, cat√©gorie):
        filename = f"{nom.lower().replace(' ', '_')}.json"
        file_path = os.path.join(self.output_dir, cat√©gorie.lower().replace(" ", "_"), filename)

        if not os.path.exists(file_path):
            print(f"‚ùå Profil non trouv√© : {filename}")
            return None

        try:
            with open(file_path, encoding="utf-8") as f:
                data = json.load(f)
            print(f"üì• Profil charg√© : {data.get('name')}")
            return data
        except Exception as e:
            print(f"‚ùå Erreur lors du chargement : {e}")
            return None

    def proposer_depuis_memoire(self, √©motion, contexte, relation_context="neutre"):
        nom = f"√âcho {√©motion.capitalize()}"
        playlist = [√©motion]
        self.proposer_nouveau_profil(
            nom=nom, playlist=playlist, contexte=contexte, cat√©gorie="m√©moire", relation_context=relation_context
        )

    def d√©duire_profil_recommand√©(self, emotion):
        emotion = emotion.lower()
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json"):
                        file_path = os.path.join(dossier, fichier)
                        try:
                            with open(file_path, encoding="utf-8") as f:
                                data = json.load(f)
                            if data.get("approved_by_david", False):
                                playlist = [e.lower() for e in data.get("playlist", [])]
                                if emotion in playlist:
                                    print(f"üí° Suggestion : profil '{data.get('name')}' (cat√©gorie : {cat√©gorie})")
                                    return data
                        except Exception as e:
                            print(f"‚ùå Erreur sur {fichier} : {e}")
        print(f"üîç Aucun profil valid√© ne contient l‚Äô√©motion : {emotion}")
        return None

    def proposer_profil_recommand√©(self, emotion):
        profil = self.d√©duire_profil_recommand√©(emotion)
        if profil:
            print(f"\nüó£Ô∏è Jeffrey : Je ressens une dominante '{emotion}'.")
            print(f"Souhaites-tu que je passe en mode ¬´ {profil.get('name')} ¬ª ? üí´")
        else:
            print(f"\nüó£Ô∏è Jeffrey : Je ne trouve aucun profil valid√© correspondant √† l‚Äô√©motion ¬´ {emotion} ¬ª.")

    def filtrer_par_contexte_relationnel(self, contexte_relationnel):
        print(f"üìÇ Profils pour le contexte relationnel : '{contexte_relationnel}'")
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json"):
                        try:
                            with open(os.path.join(dossier, fichier), encoding="utf-8") as f:
                                data = json.load(f)
                            if (
                                data.get("approved_by_david", False)
                                and data.get("relation_context") == contexte_relationnel
                            ):
                                print(f" - {data.get('name')} ({cat√©gorie}/{fichier})")
                        except Exception as e:
                            print(f"‚ùå Erreur sur {fichier} : {e}")

    def changer_contexte_relationnel(self, nouveau_contexte, emotion_dominante="neutre"):
        print(f"\nüîÑ Changement de contexte d√©tect√© : {self.contexte_actuel} ‚Üí {nouveau_contexte}")
        self.contexte_actuel = nouveau_contexte

        profils_adapt√©s = []
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json"):
                        try:
                            with open(os.path.join(dossier, fichier), encoding="utf-8") as f:
                                data = json.load(f)
                            if (
                                data.get("approved_by_david", False)
                                and data.get("relation_context") == nouveau_contexte
                            ):
                                profils_adapt√©s.append((data, fichier, cat√©gorie))
                        except Exception as e:
                            print(f"‚ùå Erreur sur {fichier} : {e}")

        if not profils_adapt√©s:
            print("‚ö†Ô∏è Aucun profil adapt√© trouv√© pour ce contexte.")
            return

        for data, fichier, cat√©gorie in profils_adapt√©s:
            playlist = [e.lower() for e in data.get("playlist", [])]
            if emotion_dominante.lower() in playlist:
                print(f"‚úÖ Profil s√©lectionn√© : {data.get('name')} ({cat√©gorie}/{fichier})")
                profil_data = self.charger_profil(data.get("name"), cat√©gorie)
                if profil_data:
                    self.transition_vers_profil(profil_data)
                return

        print("‚ö†Ô∏è Aucun profil √©motionnellement compatible trouv√©. Contexte mis √† jour sans bascule automatique.")

    def transition_vers_profil(self, nouveau_profil, courbe="ease-in-out"):
        """
        Effectue une transition dynamique et r√©aliste entre profils √©motionnels,
        avec animation non lin√©aire (ease-in, ease-out, ease-in-out) pour plus de r√©alisme.
        """
        if not nouveau_profil:
            print("‚ö†Ô∏è Aucune donn√©e de profil fournie pour la transition.")
            return

        # Incr√©menter le compteur d'utilisation si le profil a √©t√© auto-g√©n√©r√©
        try:
            dossier = os.path.join(self.output_dir, nouveau_profil.get("category", "autre").lower().replace(" ", "_"))
            fichier = f"{nouveau_profil.get('name').lower().replace(' ', '_')}.json"
            chemin = os.path.join(dossier, fichier)

            if os.path.exists(chemin):
                with open(chemin, encoding="utf-8") as f:
                    data = json.load(f)
                data["usage_count"] = data.get("usage_count", 0) + 1
                with open(chemin, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=2, ensure_ascii=False)

                if data["usage_count"] >= 5:
                    print(
                        f"üîÅ Le profil ¬´ {data['name']} ¬ª est souvent utilis√© ({data['usage_count']} fois). Une version √©volu√©e va √™tre g√©n√©r√©e automatiquement."
                    )
                    self.g√©n√©rer_version_√©volu√©e(data['name'])

                # Marquer comme favori si tr√®s utilis√©
                if data["usage_count"] >= 8 and not data.get("favorite", False):
                    data["favorite"] = True
                    print(f"‚≠ê Le profil ¬´ {data['name']} ¬ª est d√©sormais marqu√© comme FAVORI (usage fr√©quent).")
                    with open(chemin, "w", encoding="utf-8") as f:
                        json.dump(data, f, indent=2, ensure_ascii=False)

                # Affichage dynamique des favoris √©motionnels en fonction de l'√©tat
                if data.get("favorite", False) and (emotion_dominante := nouveau_profil.get("playlist", [None])[0]):
                    print(f"üíñ Ce profil favori est align√© avec l‚Äôhumeur actuelle (¬´ {emotion_dominante} ¬ª).")
                    print("üß≠ Jeffrey pourra le sugg√©rer en priorit√© dans des contextes similaires.")

        except Exception as e:
            print(f"‚ùå Erreur mise √† jour usage_count : {e}")

        import math

        ancien = self.profil_actif or {}
        print(f"\nüé≠ Transition : {ancien.get('name', 'aucun')} ‚Üí {nouveau_profil.get('name')}")
        √©tapes = 10
        for i in range(1, √©tapes + 1):
            t = i / √©tapes
            if courbe == "ease-in":
                ratio = t * t
            elif courbe == "ease-out":
                ratio = 1 - (1 - t) ** 2
            else:  # ease-in-out
                ratio = 0.5 * (1 - math.cos(math.pi * t))
            vol = self._interpoler(ancien.get("volume", 0.5), nouveau_profil.get("volume", 0.5), ratio)
            intensit√© = self._interpoler(ancien.get("intensity", 0.5), nouveau_profil.get("intensity", 0.5), ratio)
            delay = self._interpoler(ancien.get("delay", 1.0), nouveau_profil.get("delay", 1.0), ratio)
            print(f"  √âtape {i}/{√©tapes} : Volume={vol:.2f}, Intensit√©={intensit√©:.2f}, Delay={delay:.2f}")
            # Effets visuels dynamiques selon l'√©motion dominante
            emotion = nouveau_profil.get("playlist", ["neutre"])[0].lower()
            visual_engine.trigger(f"transition_{emotion}_courbe")
            sound_engine.play_effect(f"emotion_transition_{emotion}_courbe")
        self.m√©moriser_transition_emotionnelle(nouveau_profil, self.profil_actif)
        self.profil_actif = nouveau_profil
        print(f"‚ú® Profil actif : {nouveau_profil.get('name')}")

    def transition_contextuelle_automatique(self, contexte, etat_emotionnel):
        """
        Active automatiquement un profil en fonction du contexte et de l'√©tat √©motionnel.
        """
        print(f"\nüîÑ Transition contextuelle automatique : contexte={contexte}, √©tat √©motionnel={etat_emotionnel}")
        candidats = []
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json"):
                        try:
                            with open(os.path.join(dossier, fichier), encoding="utf-8") as f:
                                data = json.load(f)
                            if (
                                data.get("approved_by_david", False)
                                and data.get("relation_context", "neutre") == contexte
                                and etat_emotionnel.lower() in [e.lower() for e in data.get("playlist", [])]
                            ):
                                candidats.append(data)
                        except Exception as e:
                            print(f"‚ùå Erreur lecture {fichier} : {e}")
        if candidats:
            # Choisit le plus utilis√© ou al√©atoirement
            profil = max(candidats, key=lambda x: x.get("usage_count", 0))
            print(f"üß≠ Profil contextuel s√©lectionn√© : {profil.get('name')}")
            self.transition_vers_profil(profil)
        else:
            print("‚ö†Ô∏è Aucun profil trouv√© pour ce contexte/√©tat. Cr√©ation d'un nouveau recommand√©.")
            self.proposer_depuis_memoire(etat_emotionnel, contexte, relation_context=contexte)

    def _interpoler(self, start, end, ratio):
        return start + (end - start) * ratio

    def m√©moriser_transition_emotionnelle(self, nouveau_profil, ancien_profil):
        try:
            os.makedirs("memory", exist_ok=True)
            log_path = "memory/emotional_log.json"

            souvenir = {
                "timestamp": datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
                "from": ancien_profil.get("name", "aucun") if ancien_profil else "aucun",
                "to": nouveau_profil.get("name"),
                "emotion": nouveau_profil.get("playlist", ["?"])[0],
                "impact": "positif",
            }

            if os.path.exists(log_path):
                with open(log_path, encoding="utf-8") as f:
                    historique = json.load(f)
            else:
                historique = []

            historique.append(souvenir)

            with open(log_path, "w", encoding="utf-8") as f:
                json.dump(historique, f, indent=2, ensure_ascii=False)

            print(f"üß† Souvenir √©motionnel enregistr√© : {souvenir['from']} ‚Üí {souvenir['to']}")

        except Exception as e:
            print(f"‚ùå Erreur m√©moire affective : {e}")

    def afficher_souvenirs_√©motionnels(self, max_entries=10):
        log_path = "memory/emotional_log.json"
        if not os.path.exists(log_path):
            print("üì≠ Aucun souvenir √©motionnel trouv√©.")
            return

        try:
            with open(log_path, encoding="utf-8") as f:
                historique = json.load(f)

            print(f"\nüìò Derniers souvenirs √©motionnels (max {max_entries}) :")
            for souvenir in historique[-max_entries:]:
                date = souvenir.get("timestamp", "?")
                origine = souvenir.get("from", "?")
                destination = souvenir.get("to", "?")
                √©motion = souvenir.get("emotion", "?")
                impact = souvenir.get("impact", "?")

                description = "üí° souvenir agr√©able" if impact == "positif" else "‚ö†Ô∏è souvenir √† surveiller"
                print(f"üïì {date} ‚Äî {origine} ‚Üí {destination} ({√©motion}) ‚Üí {description}")

        except Exception as e:
            print(f"‚ùå Erreur lors de la lecture du journal √©motionnel : {e}")

    def sugg√©rer_profil_depuis_souvenirs(self, √©motion, contexte_relationnel):
        log_path = "memory/emotional_log.json"
        if not os.path.exists(log_path):
            print("üì≠ Aucun souvenir √©motionnel trouv√©.")
            return

        try:
            with open(log_path, encoding="utf-8") as f:
                historique = json.load(f)

            profils_possibles = {}
            for souvenir in historique:
                if souvenir.get("emotion") == √©motion and souvenir.get("impact") == "positif":
                    profil = souvenir.get("to")
                    profils_possibles[profil] = profils_possibles.get(profil, 0) + 1

            if not profils_possibles:
                print("üß† Aucun souvenir √©motionnel marquant pour cette √©motion.")
                return

            profil_sugg√©r√© = max(profils_possibles, key=profils_possibles.get)
            if profils_possibles[profil_sugg√©r√©] > 1:
                print(
                    f"\nüß† R√©surgence : Je me souviens que le profil ¬´ {profil_sugg√©r√©} ¬ª t‚Äôa souvent fait du bien quand tu ressentais ¬´ {√©motion} ¬ª en contexte ¬´ {contexte_relationnel} ¬ª... üí≠"
                )
            elif random.random() < 0.33:  # 1 chance sur 3 de le proposer m√™me si peu fr√©quent
                print(f"\nüß† Peut-√™tre que le profil ¬´ {profil_sugg√©r√©} ¬ª te conviendrait, comme autrefois... üí´")
            else:
                print("ü§î Aucun rappel √©motionnel d√©clench√© pour l‚Äôinstant.")
        except Exception as e:
            print(f"‚ùå Erreur r√©surgence √©motionnelle : {e}")

    def choisir_profil_si_pas_de_souvenir(self, emotion, contexte_relationnel):
        log_path = "memory/emotional_log.json"
        profil_sugg√©r√© = None

        # Tenter une r√©surgence bas√©e sur les souvenirs
        if os.path.exists(log_path):
            try:
                with open(log_path, encoding="utf-8") as f:
                    historique = json.load(f)

                profils_possibles = {}
                for souvenir in historique:
                    if souvenir.get("emotion") == emotion and souvenir.get("impact") == "positif":
                        profil = souvenir.get("to")
                        profils_possibles[profil] = profils_possibles.get(profil, 0) + 1

                if profils_possibles:
                    profil_sugg√©r√© = max(profils_possibles, key=profils_possibles.get)
                    print(
                        f"üß† R√©surgence : Jeffrey se souvient que ¬´ {profil_sugg√©r√©} ¬ª √©tait efficace pour ¬´ {emotion} ¬ª."
                    )

            except Exception as e:
                print(f"‚ùå Erreur lecture souvenirs : {e}")

        # Si aucun souvenir pertinent
        if not profil_sugg√©r√©:
            print("üîç Aucun souvenir utile. Recherche de profils valid√©s compatibles...")
            for cat√©gorie in os.listdir(self.output_dir):
                dossier = os.path.join(self.output_dir, cat√©gorie)
                if os.path.isdir(dossier):
                    for fichier in os.listdir(dossier):
                        if fichier.endswith(".json"):
                            file_path = os.path.join(dossier, fichier)
                            try:
                                with open(file_path, encoding="utf-8") as f:
                                    data = json.load(f)
                                if (
                                    data.get("approved_by_david", False)
                                    and data.get("relation_context") == contexte_relationnel
                                    and emotion.lower() in [e.lower() for e in data.get("playlist", [])]
                                ):
                                    print(f"üí° Suggestion : profil valid√© ¬´ {data.get('name')} ¬ª trouv√©.")
                                    self.transition_vers_profil(data)
                                    return
                            except Exception as e:
                                print(f"‚ùå Erreur lecture profil : {e}")

            print("üì• Aucun profil compatible trouv√©. Jeffrey va en cr√©er un nouveau.")
            self.proposer_depuis_memoire(emotion, contexte_relationnel, relation_context=contexte_relationnel)

    def g√©n√©rer_version_√©volu√©e(self, nom_profil, ajustement=0.1):
        """Cr√©e une version am√©lior√©e du profil utilis√© fr√©quemment"""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)

                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            original = json.load(f)

                        # Cr√©ation du nouveau profil
                        nouveau_nom = f"{original['name']}+"
                        nouvelle_version = original.copy()
                        nouvelle_version["name"] = nouveau_nom
                        nouvelle_version["origin"] = "auto_evolved"
                        nouvelle_version["created_on"] = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
                        nouvelle_version["volume"] = min(original.get("volume", 0.5) + ajustement, 1.0)
                        nouvelle_version["intensity"] = min(original.get("intensity", 0.5) + ajustement, 1.0)
                        nouvelle_version["delay"] = max(original.get("delay", 1.0) - ajustement, 0.2)
                        nouvelle_version["approved_by_david"] = False
                        nouvelle_version["usage_count"] = 0

                        # Enregistrement
                        nouveau_fichier = f"{nouveau_nom.lower().replace(' ', '_')}.json"
                        nouveau_chemin = os.path.join(dossier, nouveau_fichier)

                        with open(nouveau_chemin, "w", encoding="utf-8") as f:
                            json.dump(nouvelle_version, f, indent=2, ensure_ascii=False)

                        print(f"üß¨ Version √©volu√©e g√©n√©r√©e : {nouveau_nom}")
                        self.transition_vers_profil(nouvelle_version)
                        # Historisation de l'√©volution du profil
                        self.historiser_√©volution_profil(original["name"])
                        return

                    except Exception as e:
                        print(f"‚ùå Erreur lors de la g√©n√©ration de la version √©volu√©e : {e}")
        print(f"‚ùå Profil de base introuvable pour √©volution : {nom_profil}")

    def regrouper_profils_par_ambiance(self):
        """Classe dynamiquement les profils par ambiance √©motionnelle dominante"""
        ambiance_map = {}

        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json"):
                        chemin = os.path.join(dossier, fichier)
                        try:
                            with open(chemin, encoding="utf-8") as f:
                                data = json.load(f)

                            √©motion_principale = data.get("playlist", ["autre"])[0]
                            ambiance = √©motion_principale.lower()

                            if ambiance not in ambiance_map:
                                ambiance_map[ambiance] = []
                            ambiance_map[ambiance].append(data.get("name"))

                        except Exception as e:
                            print(f"‚ùå Erreur lecture profil {fichier} : {e}")

        print("\nüé® Profils regroup√©s par ambiance dominante :")
        for ambiance, noms in ambiance_map.items():
            print(f"\nüåà Ambiance : {ambiance} ({len(noms)} profils)")
            for nom in noms:
                print(f" - {nom}")

    def d√©tecter_profils_inutilis√©s(self, seuil_jours=30):
        """D√©tecte les profils non utilis√©s depuis X jours ou jamais utilis√©s"""
        print(f"\nüìâ D√©tection des profils inutilis√©s depuis plus de {seuil_jours} jours :")
        now = time.time()
        seuil_secondes = seuil_jours * 86400

        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json"):
                        chemin = os.path.join(dossier, fichier)
                        try:
                            last_modified = os.path.getmtime(chemin)
                            delta = now - last_modified
                            with open(chemin, encoding="utf-8") as f:
                                data = json.load(f)
                            if data.get("usage_count", 0) == 0 or delta > seuil_secondes:
                                statut = (
                                    "jamais utilis√©"
                                    if data.get("usage_count", 0) == 0
                                    else f"inutilis√© depuis {int(delta / 86400)} jours"
                                )
                                print(f" - {data.get('name')} ({cat√©gorie}/{fichier}) ‚Üí {statut}")
                        except Exception as e:
                            print(f"‚ùå Erreur analyse {fichier} : {e}")

    def supprimer_profils_obsol√®tes(self, seuil_jours=30, confirmer=True):
        """Supprime les profils non utilis√©s depuis X jours apr√®s confirmation, sauf les profils favoris"""
        print(f"\nüóëÔ∏è Suppression douce des profils inutilis√©s (seuil : {seuil_jours} jours)")
        now = time.time()
        seuil_secondes = seuil_jours * 86400
        profils_supprim√©s = []

        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json"):
                        chemin = os.path.join(dossier, fichier)
                        try:
                            last_modified = os.path.getmtime(chemin)
                            delta = now - last_modified
                            with open(chemin, encoding="utf-8") as f:
                                data = json.load(f)

                            if data.get("usage_count", 0) == 0 or delta > seuil_secondes:
                                # Protection contre la suppression des profils favoris
                                if data.get("favorite", False):
                                    print(f"üõ°Ô∏è Profil favori prot√©g√© : {data.get('name')} (non supprim√©)")
                                    continue
                                if confirmer:
                                    print(
                                        f"‚ùì Supprimer ¬´ {data.get('name')} ¬ª ({cat√©gorie}/{fichier}) ? [o/n] ", end=""
                                    )
                                    choix = input().strip().lower()
                                    if choix != "o":
                                        continue
                                os.remove(chemin)
                                profils_supprim√©s.append(data.get("name"))
                        except Exception as e:
                            print(f"‚ùå Erreur suppression {fichier} : {e}")

        if profils_supprim√©s:
            print("\n‚úÖ Profils supprim√©s :")
            for nom in profils_supprim√©s:
                print(f" - {nom}")
        else:
            print("üì¶ Aucun profil supprim√©.")

    def archiver_anciens_favoris_remplac√©s(self):
        """Archive les anciens profils favoris qui ont √©t√© remplac√©s par une version √©volu√©e"""
        print("\nüì¶ Archivage des anciens profils favoris remplac√©s :")
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json") and not fichier.endswith("+.json"):
                        chemin = os.path.join(dossier, fichier)
                        chemin_version_plus = os.path.join(dossier, fichier.replace(".json", "+.json"))
                        try:
                            if os.path.exists(chemin_version_plus):
                                with open(chemin, encoding="utf-8") as f:
                                    data = json.load(f)

                                if data.get("favorite", False):
                                    archive_dir = os.path.join("archive", cat√©gorie)
                                    os.makedirs(archive_dir, exist_ok=True)
                                    new_path = os.path.join(archive_dir, fichier)
                                    os.rename(chemin, new_path)
                                    print(f"üìÅ Archiv√© : {data['name']} ‚Üí {new_path}")
                        except Exception as e:
                            print(f"‚ùå Erreur archivage {fichier} : {e}")

    def historiser_√©volution_profil(self, nom_profil):
        """Cr√©e ou met √† jour un journal d‚Äô√©volution pour un profil donn√©"""
        try:
            historique_dir = "history"
            os.makedirs(historique_dir, exist_ok=True)
            fichier_historique = os.path.join(historique_dir, f"{nom_profil.lower().replace(' ', '_')}_log.json")

            log_entry = {
                "timestamp": datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
                "profil": nom_profil,
                "√©v√©nement": "√©volution g√©n√©r√©e automatiquement",
            }

            if os.path.exists(fichier_historique):
                with open(fichier_historique, encoding="utf-8") as f:
                    historique = json.load(f)
            else:
                historique = []

            historique.append(log_entry)

            with open(fichier_historique, "w", encoding="utf-8") as f:
                json.dump(historique, f, indent=2, ensure_ascii=False)

            print(f"üìö Journal mis √† jour pour ¬´ {nom_profil} ¬ª dans {fichier_historique}")
        except Exception as e:
            print(f"‚ùå Erreur lors de l‚Äôhistorisation : {e}")

    def tracer_evolution_profil(self, nom_profil):
        """Affiche graphiquement l‚Äô√©volution d‚Äôun profil dans le temps (journal simplifi√©)"""
        import matplotlib.pyplot as plt

        try:
            fichier_historique = os.path.join("history", f"{nom_profil.lower().replace(' ', '_')}_log.json")
            if not os.path.exists(fichier_historique):
                print(f"üì≠ Aucun historique trouv√© pour ¬´ {nom_profil} ¬ª")
                return

            with open(fichier_historique, encoding="utf-8") as f:
                historique = json.load(f)

            dates = [entry["timestamp"] for entry in historique]
            index = list(range(1, len(dates) + 1))

            plt.figure(figsize=(10, 4))
            plt.plot(index, index, marker='o', linestyle='-', color='mediumslateblue')
            plt.xticks(index, dates, rotation=45, ha="right")
            plt.title(f"√âvolution du profil ¬´ {nom_profil} ¬ª")
            plt.xlabel("Version")
            plt.ylabel("Progression")
            plt.tight_layout()
            plt.grid(True)
            plt.show()

        except Exception as e:
            print(f"‚ùå Erreur lors du trac√© de l‚Äô√©volution : {e}")

    def dupliquer_profil(self, nom_profil, nouveau_nom=None, ajustements={}):
        """Cr√©e une copie d‚Äôun profil existant avec possibilit√© de personnalisation"""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)

                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            original = json.load(f)

                        clone = original.copy()
                        clone["name"] = nouveau_nom or f"{original['name']} (copie)"
                        clone["origin"] = "user_cloned"
                        clone["created_on"] = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
                        clone["approved_by_david"] = False
                        clone["usage_count"] = 0
                        clone.update(ajustements)

                        nom_fichier = f"{clone['name'].lower().replace(' ', '_')}.json"
                        chemin_clone = os.path.join(dossier, nom_fichier)

                        with open(chemin_clone, "w", encoding="utf-8") as f:
                            json.dump(clone, f, indent=2, ensure_ascii=False)

                        print(f"üìë Profil dupliqu√© : {clone['name']} ‚Üí {chemin_clone}")
                        return

                    except Exception as e:
                        print(f"‚ùå Erreur duplication : {e}")
                        return
        print(f"‚ùå Impossible de trouver le profil ¬´ {nom_profil} ¬ª √† dupliquer.")

    def personnaliser_profil_en_dialogue(self, nom_profil):
        """Propose √† l'utilisateur de modifier un profil √©tape par √©tape"""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)
                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)

                        print(f"\nüé® Personnalisation du profil : {data['name']}")
                        nv_nom = input(f"üìù Nouveau nom (laisser vide pour conserver ¬´ {data['name']} ¬ª) : ").strip()
                        if nv_nom:
                            data["name"] = nv_nom

                        for champ, label in [
                            ("volume", "volume (0.0‚Äì1.0)"),
                            ("intensity", "intensit√© (0.0‚Äì1.0)"),
                            ("delay", "d√©lai (en secondes)"),
                        ]:
                            val = input(f"üîß {label} [actuel : {data.get(champ)}] : ").strip()
                            if val:
                                try:
                                    data[champ] = float(val)
                                except ValueError:
                                    print(f"‚ö†Ô∏è Valeur non valide ignor√©e pour {champ}")

                        contexte = input(
                            f"üåê Contexte relationnel [actuel : {data.get('relation_context')}] : "
                        ).strip()
                        if contexte:
                            data["relation_context"] = contexte

                        clone_nom = f"{data['name']}+perso"
                        data["origin"] = "user_personalized"
                        data["created_on"] = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
                        data["approved_by_david"] = False
                        data["usage_count"] = 0
                        nom_fichier = f"{clone_nom.lower().replace(' ', '_')}.json"
                        chemin_clone = os.path.join(dossier, nom_fichier)

                        with open(chemin_clone, "w", encoding="utf-8") as f:
                            json.dump(data, f, indent=2, ensure_ascii=False)

                        print(f"‚úÖ Profil personnalis√© enregistr√© : {clone_nom}")
                        return
                    except Exception as e:
                        print(f"‚ùå Erreur personnalisation : {e}")
                        return
        print(f"‚ùå Profil introuvable pour personnalisation : {nom_profil}")

    def pr√©visualiser_profil(self, nom_profil):
        """Pr√©visualise les effets sonores et visuels d‚Äôun profil sans l‚Äôactiver"""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)

                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)

                        print(f"\nüëÅÔ∏è Pr√©visualisation du profil ¬´ {data.get('name')} ¬ª")
                        print(
                            f"üéõÔ∏è Volume : {data.get('volume')}, Intensit√© : {data.get('intensity')}, D√©lai : {data.get('delay')}s"
                        )

                        # D√©clenche les effets visuels et sonores sans transition r√©elle
                        visual_engine.trigger("pr√©visualisation_lumiere")
                        sound_engine.play_effect("emotion_preview")

                        print("üé¨ Effets d√©clench√©s pour aper√ßu sensoriel.")
                        return
                    except Exception as e:
                        print(f"‚ùå Erreur de pr√©visualisation : {e}")
                        return
        print(f"‚ùå Profil introuvable pour pr√©visualisation : {nom_profil}")

    def √©diter_profil(self, nom_profil):
        """Modifie un profil existant directement via la console (sans duplication)"""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)
                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)

                        print(f"\n‚úèÔ∏è Modification du profil : {data['name']}")

                        for champ, label in [
                            ("volume", "volume (0.0‚Äì1.0)"),
                            ("intensity", "intensit√© (0.0‚Äì1.0)"),
                            ("delay", "d√©lai (en secondes)"),
                            ("relation_context", "contexte relationnel"),
                        ]:
                            val = input(f"üîß {label} [actuel : {data.get(champ)}] : ").strip()
                            if val:
                                try:
                                    data[champ] = float(val) if champ != "relation_context" else val
                                except ValueError:
                                    print(f"‚ö†Ô∏è Valeur non valide ignor√©e pour {champ}")

                        with open(chemin, "w", encoding="utf-8") as f:
                            json.dump(data, f, indent=2, ensure_ascii=False)

                        print(f"‚úÖ Profil mis √† jour : {data['name']}")
                        return
                    except Exception as e:
                        print(f"‚ùå Erreur √©dition : {e}")
                        return
        print(f"‚ùå Profil introuvable pour √©dition : {nom_profil}")

    def √©dition_rapide_interface(self):
        """Mini interface texte pour modifier un profil existant"""
        print("\nüß© √âdition rapide d‚Äôun profil √©motionnel")
        nom_profil = input("üîç Nom du profil √† modifier : ").strip()
        if not nom_profil:
            print("‚ö†Ô∏è Aucun nom fourni.")
            return

        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)

                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)

                        print(f"\nüéØ Modification directe de ¬´ {data['name']} ¬ª")

                        champs_editables = ["volume", "intensity", "delay", "relation_context", "playlist"]
                        for champ in champs_editables:
                            val = input(f"üîß {champ} [actuel : {data.get(champ)}] : ").strip()
                            if val:
                                try:
                                    if champ == "playlist":
                                        data[champ] = [e.strip() for e in val.split(",")]
                                    elif champ == "relation_context":
                                        data[champ] = val
                                    else:
                                        data[champ] = float(val)
                                except ValueError:
                                    print(f"‚ö†Ô∏è Valeur ignor√©e pour {champ}")

                        with open(chemin, "w", encoding="utf-8") as f:
                            json.dump(data, f, indent=2, ensure_ascii=False)

                        print(f"‚úÖ Modifications enregistr√©es pour : {data['name']}")
                        return
                    except Exception as e:
                        print(f"‚ùå Erreur lors de l‚Äô√©dition : {e}")
                        return

        print(f"‚ùå Profil ¬´ {nom_profil} ¬ª introuvable.")

    def simuler_activation_profil(self, nom_profil):
        """Effectue une simulation compl√®te du profil (visuel + audio) avant validation"""
        print(f"\nüß™ Simulation du profil ¬´ {nom_profil} ¬ª...")

        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)

                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)

                        print(
                            f"\nüéß Param√®tres : Volume={data.get('volume')} / Intensit√©={data.get('intensity')} / D√©lai={data.get('delay')}s"
                        )
                        print(f"üéµ Playlist : {data.get('playlist')}")
                        print(f"üåê Contexte : {data.get('relation_context')}")

                        print("üîä D√©clenchement des effets en simulation...")
                        visual_engine.trigger("simulation_transition")
                        sound_engine.play_effect("emotion_simulation")

                        confirmation = input("‚úÖ Ce profil te convient-il ? (o/n) ").strip().lower()
                        if confirmation == "o":
                            self.valider_profil(data["name"])
                        else:
                            print("‚ùå Profil non valid√©, simulation termin√©e.")
                        return

                    except Exception as e:
                        print(f"‚ùå Erreur simulation : {e}")
                        return
        print(f"‚ùå Profil ¬´ {nom_profil} ¬ª introuvable pour simulation.")

    def cat√©goriser_automatiquement_profils(self):
        """Assigne dynamiquement une cat√©gorie √† chaque profil selon les √©motions dominantes"""
        print("\nüß† Cat√©gorisation automatique des profils...")
        nouvelles_cat√©gories = {}

        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if not os.path.isdir(dossier):
                continue

            for fichier in os.listdir(dossier):
                if fichier.endswith(".json"):
                    chemin = os.path.join(dossier, fichier)
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)

                        emotion = data.get("playlist", [""])[0].lower()
                        if "joie" in emotion or "rire" in emotion:
                            nouvelle_cat = "positif"
                        elif "tristesse" in emotion or "solitude" in emotion:
                            nouvelle_cat = "m√©lancolie"
                        elif "col√®re" in emotion or "tension" in emotion:
                            nouvelle_cat = "intense"
                        elif "calme" in emotion or "zen" in emotion:
                            nouvelle_cat = "apaisant"
                        else:
                            nouvelle_cat = "neutre"

                        if nouvelle_cat != cat√©gorie:
                            nouvelles_cat√©gories[chemin] = nouvelle_cat

                    except Exception as e:
                        print(f"‚ùå Erreur lecture {fichier} : {e}")

        for chemin, nouvelle_cat in nouvelles_cat√©gories.items():
            try:
                os.makedirs(os.path.join(self.output_dir, nouvelle_cat), exist_ok=True)
                nouveau_chemin = os.path.join(self.output_dir, nouvelle_cat, os.path.basename(chemin))
                os.rename(chemin, nouveau_chemin)
                print(f"üìÇ {os.path.basename(chemin)} ‚Üí {nouvelle_cat}")
            except Exception as e:
                print(f"‚ùå Erreur de d√©placement : {e}")

    def adapter_environnement_depuis_cat√©gorie(self, nom_profil):
        """Personnalise les lumi√®res et sons en fonction de la cat√©gorie du profil"""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if not os.path.isdir(dossier):
                continue

            fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
            chemin = os.path.join(dossier, fichier)

            if os.path.exists(chemin):
                try:
                    with open(chemin, encoding="utf-8") as f:
                        data = json.load(f)

                    cat√©gorie = cat√©gorie.lower()
                    if cat√©gorie == "positif":
                        visual_engine.trigger("lumiere_chaude")
                        sound_engine.play_effect("harmonie_douce")
                    elif cat√©gorie == "m√©lancolie":
                        visual_engine.trigger("lumiere_bleut√©e")
                        sound_engine.play_effect("notes_lentes")
                    elif cat√©gorie == "intense":
                        visual_engine.trigger("flash_rythmique")
                        sound_engine.play_effect("battement_fort")
                    elif cat√©gorie == "apaisant":
                        visual_engine.trigger("halo_doux")
                        sound_engine.play_effect("brise_l√©g√®re")
                    else:
                        visual_engine.trigger("lumiere_neutre")
                        sound_engine.play_effect("fond_minimal")

                    print(f"üßø Environnement adapt√© pour la cat√©gorie : {cat√©gorie}")
                    return
                except Exception as e:
                    print(f"‚ùå Erreur adaptation environnementale : {e}")
                    return

        print(f"‚ùå Profil non trouv√© pour adaptation : {nom_profil}")

    def ambiance_immersive_combin√©e(self, nom_profil):
        """Cr√©e une ambiance immersive compl√®te (lumi√®re + son + animation visuelle) pour un profil donn√©"""
        print(f"\nüåå Ambiance immersive pour ¬´ {nom_profil} ¬ª")

        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if not os.path.isdir(dossier):
                continue

            fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
            chemin = os.path.join(dossier, fichier)

            if os.path.exists(chemin):
                try:
                    with open(chemin, encoding="utf-8") as f:
                        data = json.load(f)

                    emotion = data.get("playlist", ["neutre"])[0].lower()
                    visual_engine.trigger(f"ambiance_{emotion}")
                    sound_engine.play_effect(f"son_ambiant_{emotion}")
                    visual_engine.trigger("animation_background")

                    print(f"üé® Ambiance immersive d√©clench√©e pour √©motion : {emotion}")
                    return
                except Exception as e:
                    print(f"‚ùå Erreur ambiance immersive : {e}")
                    return

        print(f"‚ùå Impossible de cr√©er l‚Äôambiance immersive pour ¬´ {nom_profil} ¬ª")

    def pr√©activer_depuis_souvenirs(self):
        """Pr√©-active une ambiance immersive selon les souvenirs √©motionnels r√©cents"""
        log_path = "memory/emotional_log.json"
        if not os.path.exists(log_path):
            print("üì≠ Aucun souvenir √©motionnel disponible pour pr√©activation.")
            return

        try:
            with open(log_path, encoding="utf-8") as f:
                historique = json.load(f)

            derniers = historique[-5:]
            poids = {}
            for souvenir in derniers:
                profil = souvenir.get("to")
                if profil:
                    poids[profil] = poids.get(profil, 0) + 1

            if not poids:
                print("ü§∑‚Äç Aucun profil marquant d√©tect√© dans les derniers souvenirs.")
                return

            meilleur = max(poids, key=poids.get)
            print(f"üîÆ Pr√©activation douce du profil : {meilleur}")
            self.ambiance_immersive_combin√©e(meilleur)

        except Exception as e:
            print(f"‚ùå Erreur de pr√©activation depuis souvenirs : {e}")

    def √©viter_r√©p√©tition_profils_tristes(self, seuil=3):
        """√âvite d‚Äôactiver plusieurs fois de suite des profils tristes (m√©lancolie)"""
        log_path = "memory/emotional_log.json"
        if not os.path.exists(log_path):
            return

        try:
            with open(log_path, encoding="utf-8") as f:
                historique = json.load(f)

            r√©cents = [
                s
                for s in historique[-seuil:]
                if s.get("emotion", "").lower() in ["tristesse", "solitude", "m√©lancolie"]
            ]
            if len(r√©cents) >= seuil:
                print("üõ°Ô∏è Jeffrey : Trop de profils tristes r√©cents d√©tect√©s. Pause √©motionnelle recommand√©e.")
                return False  # Blocage de l'activation
            return True
        except Exception as e:
            print(f"‚ùå Erreur analyse des profils tristes : {e}")
            return True

    def activer_profil_joyeux_si_surcharge_triste(self):
        """Active automatiquement un profil joyeux en cas de surcharge de profils tristes"""
        if not self.√©viter_r√©p√©tition_profils_tristes():
            print("‚ö†Ô∏è Trop de profils tristes d√©tect√©s. Activation d‚Äôun profil joyeux recommand√©.")

            # Chercher un profil joyeux
            profil_joyeux = None
            for cat√©gorie in os.listdir(self.output_dir):
                dossier = os.path.join(self.output_dir, cat√©gorie)
                if os.path.isdir(dossier):
                    for fichier in os.listdir(dossier):
                        if fichier.endswith(".json"):
                            chemin = os.path.join(dossier, fichier)
                            try:
                                with open(chemin, encoding="utf-8") as f:
                                    data = json.load(f)

                                if "joie" in (data.get("playlist", [])):
                                    profil_joyeux = data
                                    break
                            except Exception as e:
                                print(f"‚ùå Erreur lecture {fichier} : {e}")
                    if profil_joyeux:
                        break

            if profil_joyeux:
                print(f"üéâ Activation d‚Äôun profil joyeux : {profil_joyeux['name']}")
                self.transition_vers_profil(profil_joyeux)
            else:
                print("‚ùå Aucun profil joyeux trouv√© dans les profils valid√©s.")
        else:
            print("‚úÖ Pas de surcharge de profils tristes d√©tect√©e.")

    def m√©moriser_relation_entre_profils(self, profil_ancien, profil_nouveau):
        """Cr√©e une m√©moire de transition relationnelle entre deux profils √©motionnels"""
        log_path = "memory/emotional_relationship_log.json"
        try:
            os.makedirs("memory", exist_ok=True)

            relation = {
                "timestamp": datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
                "from": profil_ancien.get("name", "aucun"),
                "to": profil_nouveau.get("name"),
                "emotion_from": profil_ancien.get("playlist", ["?"])[0],
                "emotion_to": profil_nouveau.get("playlist", ["?"])[0],
                "transition_type": "smooth"
                if profil_ancien.get("intensity", 0.5) < profil_nouveau.get("intensity", 0.5)
                else "abrupt",
            }

            if os.path.exists(log_path):
                with open(log_path, encoding="utf-8") as f:
                    historique = json.load(f)
            else:
                historique = []

            historique.append(relation)

            with open(log_path, "w", encoding="utf-8") as f:
                json.dump(historique, f, indent=2, ensure_ascii=False)

            print(f"üß† Relation m√©moris√©e : {relation['from']} ‚Üí {relation['to']}")

        except Exception as e:
            print(f"‚ùå Erreur lors de la m√©morisation de la relation : {e}")

    def interface_utilisateur(self):
        """Interface CLI basique pour la gestion des profils"""
        print("\nüîß Interface de gestion des profils √©motionnels")
        print("1. Ajouter un profil")
        print("2. Modifier un profil")
        print("3. Lister les profils")
        print("4. Lister les profils non valid√©s")
        print("5. Supprimer un profil non valid√©")
        print("6. Valider un profil")
        print("7. Quitter")

        choix = input("Choix (1-7) : ").strip()

        if choix == "1":
            nom = input("Nom du profil : ").strip()
            contexte = input("Contexte du profil : ").strip()
            playlist = input("Playlist (s√©par√©e par des virgules) : ").strip().split(",")
            self.proposer_nouveau_profil(nom, playlist, contexte)
        elif choix == "2":
            nom = input("Nom du profil √† modifier : ").strip()
            self.√©dition_rapide_interface()
        elif choix == "3":
            self.lister_profils_non_valides()
        elif choix == "4":
            self.lister_profils_non_valides()
        elif choix == "5":
            nom = input("Nom du profil √† supprimer : ").strip()
            self.supprimer_profil_non_valide(nom)
        elif choix == "6":
            nom = input("Nom du profil √† valider : ").strip()
            self.valider_profil(nom)
        elif choix == "7":
            print("Au revoir !")
            return
        else:
            print("Choix invalide.")
        self.interface_utilisateur()

    def transition_dynamique_environnement(self, profil_ancien, profil_nouveau):
        """Transition fluide entre les effets visuels et sonores selon les profils"""
        try:
            ancien_effect = profil_ancien.get("playlist", ["neutre"])[0]
            nouveau_effect = profil_nouveau.get("playlist", ["neutre"])[0]

            if ancien_effect != nouveau_effect:
                print(f"üé¨ Transition des effets entre {ancien_effect} ‚Üí {nouveau_effect}")
                visual_engine.trigger(f"transition_{ancien_effect}_{nouveau_effect}")
                sound_engine.play_effect(f"transition_{ancien_effect}_{nouveau_effect}")
            else:
                print(f"üîÑ Aucun changement d‚Äôambiance n√©cessaire : {ancien_effect}")

        except Exception as e:
            print(f"‚ùå Erreur lors de la transition dynamique : {e}")

    def gestion_√©motions_avanc√©e(self, contexte_relationnel="neutre"):
        """G√®re les √©motions en fonction des interactions pass√©es et du contexte actuel"""
        print(f"\nüé≠ Gestion des √©motions pour le contexte : {contexte_relationnel}")
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for fichier in os.listdir(dossier):
                    if fichier.endswith(".json"):
                        try:
                            with open(os.path.join(dossier, fichier), encoding="utf-8") as f:
                                data = json.load(f)
                            if (
                                data.get("approved_by_david", False)
                                and data.get("relation_context") == contexte_relationnel
                            ):
                                print(f" - {data.get('name')} : Profil compatible pour contexte relationnel.")
                                # Application dynamique des effets en fonction de l‚Äôhumeur pass√©e
                                self.transition_dynamique_environnement(self.profil_actif, data)
                        except Exception as e:
                            print(f"‚ùå Erreur sur {fichier} : {e}")

    def m√©moriser_souvenirs_emotionnels(self, profil_ancien, profil_nouveau, type_transition):
        """M√©morise les souvenirs √©motionnels et les relations entre profils"""
        try:
            log_path = "memory/emotional_log.json"
            os.makedirs("memory", exist_ok=True)

            souvenir = {
                "timestamp": datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
                "from": profil_ancien.get("name", "aucun"),
                "to": profil_nouveau.get("name"),
                "emotion_from": profil_ancien.get("playlist", ["?"])[0],
                "emotion_to": profil_nouveau.get("playlist", ["?"])[0],
                "transition_type": type_transition,
            }

            if os.path.exists(log_path):
                with open(log_path, encoding="utf-8") as f:
                    historique = json.load(f)
            else:
                historique = []

            historique.append(souvenir)

            with open(log_path, "w", encoding="utf-8") as f:
                json.dump(historique, f, indent=2, ensure_ascii=False)

            print(f"üß† Souvenir m√©moris√© : {souvenir['from']} ‚Üí {souvenir['to']} ({souvenir['transition_type']})")

        except Exception as e:
            print(f"‚ùå Erreur m√©morisation des souvenirs √©motionnels : {e}")

    def analyser_relations_profils(self, seuil=2):
        """Analyse les relations entre profils √©motionnels similaires"""
        log_path = "memory/emotional_log.json"
        if not os.path.exists(log_path):
            print("üì≠ Aucun souvenir √©motionnel pour analyser les relations.")
            return

        try:
            with open(log_path, encoding="utf-8") as f:
                historique = json.load(f)

            relations = {}
            for i in range(1, len(historique)):
                ancien = historique[i - 1]
                nouveau = historique[i]
                emotion_ancien = ancien.get("emotion_to", "")
                emotion_nouveau = nouveau.get("emotion_from", "")

                if emotion_ancien == emotion_nouveau:
                    pair = (ancien["from"], nouveau["to"])
                    relations[pair] = relations.get(pair, 0) + 1

            # Filtrer les relations qui apparaissent plus que `seuil` fois
            for pair, count in relations.items():
                if count >= seuil:
                    print(f"üîó Relation fr√©quente : {pair[0]} ‚Üí {pair[1]} ({count} fois)")

        except Exception as e:
            print(f"‚ùå Erreur lors de l'analyse des relations : {e}")

    def transition_√©motionnelle_avec_m√©morisation(self, profil_ancien, profil_nouveau):
        """Transition √©motionnelle avec m√©morisation et enregistrement du type de transition"""
        type_transition = "smooth" if profil_ancien["intensity"] < profil_nouveau["intensity"] else "abrupt"
        self.m√©moriser_souvenirs_emotionnels(profil_ancien, profil_nouveau, type_transition)
        self.transition_dynamique_environnement(profil_ancien, profil_nouveau)

    # 1. Affichage d√©taill√© et √©dition avanc√©e de profil
    def afficher_d√©tails_profil(self, nom_profil):
        """Affiche les d√©tails complets d‚Äôun profil : √©motions, transitions, effets associ√©s."""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)
                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)
                        print(f"\nüîé D√©tails du profil ¬´ {data.get('name')} ¬ª")
                        print(f"  Cat√©gorie : {cat√©gorie}")
                        print(f"  Playlist d‚Äô√©motions : {data.get('playlist')}")
                        print(f"  Volume : {data.get('volume')}")
                        print(f"  Intensit√© : {data.get('intensity')}")
                        print(f"  D√©lai : {data.get('delay')}")
                        print(f"  Effets visuels/sonores : {data.get('origin')}")
                        print(f"  Contexte : {data.get('context')}")
                        print(f"  Contexte relationnel : {data.get('relation_context')}")
                        print(f"  Valid√© : {'‚úÖ' if data.get('approved_by_david') else 'üïì'}")
                        print(f"  Utilisations : {data.get('usage_count', 0)}")
                        # Afficher transitions m√©moris√©es si dispo
                        self._afficher_transitions_profil(data.get("name"))
                        return
                    except Exception as e:
                        print(f"‚ùå Erreur affichage d√©tails : {e}")
                        return
        print(f"‚ùå Profil non trouv√© pour affichage d√©taill√© : {nom_profil}")

    def _afficher_transitions_profil(self, nom_profil):
        """Affiche les transitions √©motionnelles m√©moris√©es pour ce profil"""
        log_path = "memory/emotional_log.json"
        if not os.path.exists(log_path):
            print("  (Aucune transition m√©moris√©e)")
            return
        try:
            with open(log_path, encoding="utf-8") as f:
                historique = json.load(f)
            transitions = [s for s in historique if s.get("to") == nom_profil or s.get("from") == nom_profil]
            if transitions:
                print("  Transitions m√©moris√©es :")
                for t in transitions[-5:]:
                    print(
                        f"    {t.get('from')} ‚Üí {t.get('to')} ({t.get('emotion') if 'emotion' in t else t.get('emotion_to', '?')}) [{t.get('timestamp')}]"
                    )
            else:
                print("  (Aucune transition m√©moris√©e)")
        except Exception as e:
            print(f"  ‚ùå Erreur lecture transitions : {e}")

    def √©diter_profil_avanc√©(self, nom_profil):
        """Permet de modifier tous les param√®tres avanc√©s d‚Äôun profil, y compris effets visuels/sonores."""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)
                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)
                        print(f"\n‚öôÔ∏è √âdition avanc√©e du profil : {data['name']}")
                        champs = [
                            ("name", "Nom"),
                            ("playlist", "Playlist d‚Äô√©motions (s√©par√©es par virgule)"),
                            ("volume", "Volume (0.0‚Äì1.0)"),
                            ("intensity", "Intensit√© (0.0‚Äì1.0)"),
                            ("delay", "D√©lai (en secondes)"),
                            ("relation_context", "Contexte relationnel"),
                            ("origin", "Origine (auto_generated, user_personalized, etc.)"),
                            ("category", "Cat√©gorie"),
                            ("approved_by_david", "Valid√© (True/False)"),
                        ]
                        for champ, label in champs:
                            val = input(f"üîß {label} [actuel : {data.get(champ)}] : ").strip()
                            if val:
                                try:
                                    if champ == "playlist":
                                        data[champ] = [e.strip() for e in val.split(",")]
                                    elif champ in ["volume", "intensity", "delay"]:
                                        data[champ] = float(val)
                                    elif champ == "approved_by_david":
                                        data[champ] = val.lower() in ["true", "1", "oui", "o"]
                                    else:
                                        data[champ] = val
                                except Exception as e:
                                    print(f"‚ö†Ô∏è Valeur ignor√©e pour {champ}: {e}")
                        # Effets visuels/sonores personnalis√©s ?
                        effet_visuel = input(
                            f"‚ú® Effet visuel personnalis√© (laisser vide pour conserver : {data.get('visual_effect', 'aucun')}) : "
                        ).strip()
                        if effet_visuel:
                            data["visual_effect"] = effet_visuel
                        effet_sonore = input(
                            f"üéµ Effet sonore personnalis√© (laisser vide pour conserver : {data.get('audio_effect', 'aucun')}) : "
                        ).strip()
                        if effet_sonore:
                            data["audio_effect"] = effet_sonore
                        with open(chemin, "w", encoding="utf-8") as f:
                            json.dump(data, f, indent=2, ensure_ascii=False)
                        print("‚úÖ Profil avanc√© mis √† jour.")
                        return
                    except Exception as e:
                        print(f"‚ùå Erreur √©dition avanc√©e : {e}")
                        return
        print(f"‚ùå Profil non trouv√© pour √©dition avanc√©e : {nom_profil}")

    # 2. Tests avanc√©s sur profils
    def effectuer_tests_unitaires(self):
        """Valide la gestion des profils √©motionnels et transitions basiques."""
        print("\nüß™ Test unitaire : cr√©ation, validation, transition, m√©morisation.")
        try:
            test_nom = "TestProfil"
            test_playlist = ["joie", "calme"]
            self.proposer_nouveau_profil(test_nom, test_playlist, "test_context")
            self.valider_profil(test_nom)
            profil = None
            for cat in os.listdir(self.output_dir):
                dossier = os.path.join(self.output_dir, cat)
                if os.path.isdir(dossier):
                    fichier = f"{test_nom.lower().replace(' ', '_')}.json"
                    chemin = os.path.join(dossier, fichier)
                    if os.path.exists(chemin):
                        with open(chemin, encoding="utf-8") as f:
                            profil = json.load(f)
                        break
            if profil:
                self.transition_vers_profil(profil)
                print("‚úÖ Test unitaire r√©ussi.")
            else:
                print("‚ùå Impossible de charger le profil de test.")
        except Exception as e:
            print(f"‚ùå Erreur test unitaire : {e}")

    def tester_interactions_profils(self):
        """Teste l‚Äôinteraction entre plusieurs profils et la m√©moire des transitions."""
        print("\nüîó Test des interactions et m√©morisation des transitions.")
        try:
            noms = ["TestA", "TestB"]
            for nom in noms:
                self.proposer_nouveau_profil(nom, [nom.lower()], "test_context")
                self.valider_profil(nom)
            profils = []
            for nom in noms:
                for cat in os.listdir(self.output_dir):
                    dossier = os.path.join(self.output_dir, cat)
                    if os.path.isdir(dossier):
                        fichier = f"{nom.lower().replace(' ', '_')}.json"
                        chemin = os.path.join(dossier, fichier)
                        if os.path.exists(chemin):
                            with open(chemin, encoding="utf-8") as f:
                                profils.append(json.load(f))
                            break
            if len(profils) == 2:
                self.transition_vers_profil(profils[0])
                self.transition_vers_profil(profils[1])
                print("‚úÖ Test d‚Äôinteraction r√©ussi.")
            else:
                print("‚ùå Profils de test incomplets.")
        except Exception as e:
            print(f"‚ùå Erreur test interaction : {e}")

    # 3. Optimisation de la gestion des transitions
    def optimiser_transitions(self, profil_ancien, profil_nouveau, contexte=None):
        """Optimise la fluidit√© des transitions selon le contexte et l‚Äô√©motion."""
        print("\nüîÑ Optimisation de la transition entre profils.")
        try:
            √©tapes = 7
            for i in range(1, √©tapes + 1):
                ratio = i / √©tapes
                vol = self._interpoler(profil_ancien.get("volume", 0.5), profil_nouveau.get("volume", 0.5), ratio)
                intensit√© = self._interpoler(
                    profil_ancien.get("intensity", 0.5), profil_nouveau.get("intensity", 0.5), ratio
                )
                delay = self._interpoler(profil_ancien.get("delay", 1.0), profil_nouveau.get("delay", 1.0), ratio)
                print(f"  √âtape {i}/{√©tapes} : Volume={vol:.2f}, Intensit√©={intensit√©:.2f}, Delay={delay:.2f}")
                # Ajustement dynamique selon contexte ou √©motion
                if contexte:
                    print(f"    (Contexte : {contexte})")
                visual_engine.trigger("transition_optimis√©e")
                sound_engine.play_effect("emotion_transition_optimis√©e")
            print("‚úÖ Transition optimis√©e termin√©e.")
        except Exception as e:
            print(f"‚ùå Erreur optimisation transition : {e}")

    def transition_non_lin√©aire(self, profil_ancien, profil_nouveau, courbe="ease-in-out"):
        """Effectue une transition non lin√©aire (progressive ou avec courbe d‚Äôanimation)."""
        print(
            f"\n‚è© Transition non lin√©aire ({courbe}) entre {profil_ancien.get('name', '?')} ‚Üí {profil_nouveau.get('name', '?')}"
        )
        import math

        √©tapes = 10
        for i in range(1, √©tapes + 1):
            t = i / √©tapes
            if courbe == "ease-in":
                ratio = t * t
            elif courbe == "ease-out":
                ratio = 1 - (1 - t) ** 2
            else:  # ease-in-out
                ratio = 0.5 * (1 - math.cos(math.pi * t))
            vol = self._interpoler(profil_ancien.get("volume", 0.5), profil_nouveau.get("volume", 0.5), ratio)
            intensit√© = self._interpoler(
                profil_ancien.get("intensity", 0.5), profil_nouveau.get("intensity", 0.5), ratio
            )
            print(f"  √âtape {i}/{√©tapes} : Volume={vol:.2f}, Intensit√©={intensit√©:.2f}")
            visual_engine.trigger("transition_nonlineaire")
            sound_engine.play_effect("emotion_transition_nonlineaire")
        print("‚úÖ Transition non lin√©aire termin√©e.")

    # 4. Personnalisation par l'utilisateur
    def permettre_personnalisation_utilisateur(self, nom_profil):
        """Permet √† l‚Äôutilisateur de personnaliser un profil via l‚Äôinterface (effets, intensit√©, etc.)."""
        print(f"\nüë§ Personnalisation utilisateur du profil ¬´ {nom_profil} ¬ª")
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)
                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)
                        print(
                            f"Effets actuels : visuel = {data.get('visual_effect', 'aucun')}, audio = {data.get('audio_effect', 'aucun')}"
                        )
                        visual = input("Nouveau nom d‚Äôeffet visuel (laisser vide pour conserver) : ").strip()
                        audio = input("Nouveau nom d‚Äôeffet sonore (laisser vide pour conserver) : ").strip()
                        intensit√© = input(f"Nouvelle intensit√© (actuel : {data.get('intensity')}) : ").strip()
                        if visual:
                            data["visual_effect"] = visual
                        if audio:
                            data["audio_effect"] = audio
                        if intensit√©:
                            try:
                                data["intensity"] = float(intensit√©)
                            except ValueError:
                                print("‚ö†Ô∏è Valeur d‚Äôintensit√© ignor√©e.")
                        data["origin"] = "user_customized"
                        data["approved_by_david"] = False
                        with open(chemin, "w", encoding="utf-8") as f:
                            json.dump(data, f, indent=2, ensure_ascii=False)
                        print("‚úÖ Personnalisation enregistr√©e.")
                        return
                    except Exception as e:
                        print(f"‚ùå Erreur personnalisation utilisateur : {e}")
                        return
        print("‚ùå Profil non trouv√© pour personnalisation utilisateur.")

    # 5. Interactions avanc√©es entre profils
    def g√©rer_interactions_profils(self, nom_profil_source, nom_profil_cible):
        """Ajoute des logiques d‚Äôinteraction entre deux profils (ex: tristesse‚Üíjoie)."""
        print(f"\nüîÄ Gestion avanc√©e interaction : {nom_profil_source} ‚Üí {nom_profil_cible}")
        profil_source = None
        profil_cible = None
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                for nom, ref in [(nom_profil_source, "source"), (nom_profil_cible, "cible")]:
                    fichier = f"{nom.lower().replace(' ', '_')}.json"
                    chemin = os.path.join(dossier, fichier)
                    if os.path.exists(chemin):
                        with open(chemin, encoding="utf-8") as f:
                            if ref == "source":
                                profil_source = json.load(f)
                            else:
                                profil_cible = json.load(f)
        if profil_source and profil_cible:
            # Exemple: transition sp√©ciale si source tristesse et cible joie
            if ("tristesse" in profil_source.get("playlist", [])) and ("joie" in profil_cible.get("playlist", [])):
                print("‚ú® Transition sp√©ciale de tristesse vers joie !")
                self.transition_non_lin√©aire(profil_source, profil_cible, courbe="ease-out")
                self.m√©moriser_relation_entre_profils(profil_source, profil_cible)
            else:
                print("Transition standard entre profils.")
                self.transition_vers_profil(profil_cible)
        else:
            print("‚ùå Impossible de trouver les deux profils pour interaction avanc√©e.")

    # 6. Sauvegarde et chargement de profils personnalis√©s
    def sauvegarder_profil_personnalis√©(self, nom_profil):
        """Permet √† l‚Äôutilisateur de sauvegarder un profil personnalis√© sous un nouveau nom."""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)
                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)
                        nv_nom = input("Nom du profil personnalis√© √† sauvegarder : ").strip()
                        if not nv_nom:
                            print("‚ö†Ô∏è Aucun nom fourni.")
                            return
                        data["name"] = nv_nom
                        data["origin"] = "user_custom_saved"
                        data["approved_by_david"] = False
                        data["created_on"] = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
                        nv_fichier = f"{nv_nom.lower().replace(' ', '_')}.json"
                        nv_chemin = os.path.join(dossier, nv_fichier)
                        with open(nv_chemin, "w", encoding="utf-8") as f:
                            json.dump(data, f, indent=2, ensure_ascii=False)
                        print(f"‚úÖ Profil personnalis√© sauvegard√© sous : {nv_nom}")
                        return
                    except Exception as e:
                        print(f"‚ùå Erreur sauvegarde profil personnalis√© : {e}")
                        return
        print("‚ùå Profil de base non trouv√© pour sauvegarde personnalis√©e.")

    def charger_profil_personnalis√©(self, nom_profil):
        """Charge un profil personnalis√© sauvegard√© pour utilisation future."""
        for cat√©gorie in os.listdir(self.output_dir):
            dossier = os.path.join(self.output_dir, cat√©gorie)
            if os.path.isdir(dossier):
                fichier = f"{nom_profil.lower().replace(' ', '_')}.json"
                chemin = os.path.join(dossier, fichier)
                if os.path.exists(chemin):
                    try:
                        with open(chemin, encoding="utf-8") as f:
                            data = json.load(f)
                        print(f"üì• Profil personnalis√© charg√© : {data.get('name')}")
                        return data
                    except Exception as e:
                        print(f"‚ùå Erreur chargement profil personnalis√© : {e}")
                        return None
        print("‚ùå Profil personnalis√© non trouv√©.")
        return None
