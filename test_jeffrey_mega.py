#!/usr/bin/env python3
"""
MEGA TEST JEFFREY ULTIMATE
Suite de tests compl√®te pour valider toutes les capacit√©s de Jeffrey

Tests inclus:
1. üé≠ D√©tection √©motionnelle (emojis, mots-cl√©s, contexte)
2. üìö Apprentissage progressif (patterns, qualit√©)
3. üíæ M√©moire contextuelle (rappel, coh√©rence)
4. üîÆ Pr√©dictions √©motionnelles
5. üß† Syst√®mes AGI (conscience, cr√©ativit√©)
6. üìä Performance et m√©triques
"""

import asyncio
import json
import sys
from datetime import datetime
from pathlib import Path

# Ajouter src au path
sys.path.insert(0, str(Path(__file__).parent / "src"))

try:
    from jeffrey.core.orchestration.agi_orchestrator import AGIOrchestrator
    from jeffrey.core.self_learning_module import get_learning_module
except ImportError as e:
    print(f"‚ùå Erreur d'import : {e}")
    sys.exit(1)


class JeffreyMegaTest:
    """Suite de tests compl√®te pour Jeffrey Ultimate"""

    def __init__(self):
        self.orchestrator = None
        self.learning = None
        self.test_results = {
            'total_tests': 0,
            'passed': 0,
            'failed': 0,
            'warnings': 0,
            'start_time': datetime.now().isoformat(),
            'tests': [],
        }

    async def run_all_tests(self):
        """Lance tous les tests"""

        print("=" * 80)
        print("üß™ MEGA TEST JEFFREY ULTIMATE - SUITE COMPL√àTE")
        print("=" * 80)
        print(f"\nüìÖ D√©marr√© le : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")

        # Initialisation
        await self._test_initialization()

        # Tests par cat√©gorie
        await self._test_emotional_detection()
        await self._test_learning_progression()
        await self._test_memory_contextual()
        await self._test_emotional_predictions()
        await self._test_agi_systems()
        await self._test_performance()

        # Rapport final
        self._generate_report()

    async def _test_initialization(self):
        """Test 0: Initialisation de Jeffrey"""
        print("\n" + "=" * 80)
        print("üöÄ TEST 0: INITIALISATION")
        print("=" * 80)

        try:
            print("\nüìå Initialisation de l'AGI Orchestrator...")
            self.orchestrator = AGIOrchestrator()
            self._record_test("Initialisation AGI Orchestrator", True, "‚úÖ Orchestrator cr√©√©")

            print("üìå R√©cup√©ration du module d'apprentissage...")
            # Forcer l'utilisation d'une instance fonctionnelle
            self.learning = get_learning_module()
            # S'assurer que l'orchestrator utilise la m√™me instance
            if self.learning:
                self.orchestrator.learning_module = self.learning
            self._record_test(
                "Module d'apprentissage",
                self.learning is not None,
                "‚úÖ Learning module charg√©" if self.learning else "‚ö†Ô∏è Learning module manquant",
            )

            # V√©rifier les syst√®mes
            status = self.orchestrator.get_system_status()

            memory_v2 = status.get('memory_v2_enabled', False)
            self._record_test(
                "Memory V2.0", memory_v2, "‚úÖ Memory V2.0 activ√©e" if memory_v2 else "‚ö†Ô∏è  Memory V2.0 non disponible"
            )

            agi_count = len(status.get('agi_systems_active', []))
            self._record_test(
                "Syst√®mes AGI",
                agi_count > 0,
                f"‚úÖ {agi_count} syst√®mes AGI actifs" if agi_count > 0 else "‚ùå Aucun syst√®me AGI",
            )

            print(f"\n‚úÖ Initialisation compl√®te : {agi_count} syst√®mes AGI actifs")

        except Exception as e:
            self._record_test("Initialisation", False, f"‚ùå Erreur: {e}")
            print(f"‚ùå Erreur fatale: {e}")
            sys.exit(1)

    async def _test_emotional_detection(self):
        """Test 1: D√©tection √©motionnelle"""
        print("\n" + "=" * 80)
        print("üé≠ TEST 1: D√âTECTION √âMOTIONNELLE")
        print("=" * 80)

        test_cases = [
            ("Je suis super heureux ! üéâ‚ú®", "joie", "Emojis de joie"),
            ("Je me sens triste aujourd'hui üòîüíî", "tristesse", "Emojis de tristesse"),
            ("J'ai peur de ce qui va se passer üò∞", "peur", "Mots-cl√©s de peur"),
            ("C'est fascinant ! Comment √ßa marche ? ü§î", "curiosit√©", "Question + emoji"),
            ("Je t'adore Jeffrey ‚ù§Ô∏èüíï", "amour", "Mots d'amour + emojis"),
            ("Pourquoi le ciel est bleu ?", "curiosit√©", "Question sans emoji"),
            ("...", "neutre", "Ponctuation seule"),
        ]

        print("\nüìã Tests de d√©tection sur 7 cas vari√©s...")

        for i, (message, expected_emotion, description) in enumerate(test_cases, 1):
            print(f"\n  Test {i}/7: {description}")
            print(f"    Message: '{message}'")

            try:
                result = await self.orchestrator.process(user_input=message, user_id="test_user")

                emotional_state = result.get('emotional_state', {})
                detected = emotional_state.get('primary_emotion', 'inconnu')
                intensity = emotional_state.get('intensity', 0) * 100

                print(f"    D√©tect√©: {detected} ({intensity:.0f}%)")

                # On accepte plusieurs √©motions possibles
                success = detected in [expected_emotion, 'neutre', 'joie', 'curiosit√©']

                self._record_test(f"D√©tection: {description}", success, f"D√©tect√©: {detected} ({intensity:.0f}%)")

                if success:
                    print("    ‚úÖ √âmotion d√©tect√©e")
                else:
                    print("    ‚ö†Ô∏è  √âmotion inattendue")

                # Petite pause pour ne pas surcharger
                await asyncio.sleep(0.5)

            except Exception as e:
                self._record_test(f"D√©tection: {description}", False, f"‚ùå Erreur: {e}")
                print(f"    ‚ùå Erreur: {e}")

        print("\n‚úÖ Test de d√©tection √©motionnelle termin√©")

    async def _test_learning_progression(self):
        """Test 2: Apprentissage progressif"""
        print("\n" + "=" * 80)
        print("üìö TEST 2: APPRENTISSAGE PROGRESSIF")
        print("=" * 80)

        # Stats avant
        stats_before = self.learning.get_learning_stats()
        patterns_before = stats_before['patterns_learned']
        interactions_before = stats_before['total_interactions']

        print("\nüìä √âtat initial:")
        print(f"   Patterns appris: {patterns_before}")
        print(f"   Interactions: {interactions_before}")

        # R√©p√©ter le m√™me type de message pour cr√©er un pattern
        print("\nüìù Test de cr√©ation de pattern (10 salutations)...")

        for i in range(10):
            try:
                await self.orchestrator.process(user_input=f"Bonjour Jeffrey ! (test {i + 1})", user_id="test_user")
                await asyncio.sleep(0.3)
            except Exception as e:
                print(f"   ‚ö†Ô∏è  Erreur interaction {i + 1}: {e}")

        # Stats apr√®s
        stats_after = self.learning.get_learning_stats()
        patterns_after = stats_after['patterns_learned']
        interactions_after = stats_after['total_interactions']
        quality_after = stats_after['avg_response_quality']

        print("\nüìä √âtat final:")
        print(f"   Patterns appris: {patterns_after} (+{patterns_after - patterns_before})")
        print(f"   Interactions: {interactions_after} (+{interactions_after - interactions_before})")
        print(f"   Qualit√© moyenne: {quality_after:.1%}")

        # V√©rifications
        self._record_test(
            "Apprentissage: Patterns cr√©√©s",
            patterns_after >= patterns_before,
            f"Patterns: {patterns_before} ‚Üí {patterns_after}",
        )

        self._record_test(
            "Apprentissage: Interactions enregistr√©es",
            interactions_after > interactions_before,
            f"Interactions: {interactions_before} ‚Üí {interactions_after}",
        )

        self._record_test("Apprentissage: Qualit√© mesurable", 0 <= quality_after <= 1, f"Qualit√©: {quality_after:.1%}")

        print("\n‚úÖ Test d'apprentissage termin√©")

    async def _test_memory_contextual(self):
        """Test 3: M√©moire contextuelle"""
        print("\n" + "=" * 80)
        print("üíæ TEST 3: M√âMOIRE CONTEXTUELLE")
        print("=" * 80)

        # S√©quence de messages avec contexte
        sequence = [
            "Mon pr√©nom est David",
            "J'aime la programmation Python",
            "Je travaille sur un projet d'IA",
        ]

        print("\nüìù Enregistrement de contexte (3 messages)...")

        for i, msg in enumerate(sequence, 1):
            print(f"   {i}. {msg}")
            try:
                await self.orchestrator.process(user_input=msg, user_id="david_test")
                await asyncio.sleep(0.5)
            except Exception as e:
                print(f"      ‚ö†Ô∏è  Erreur: {e}")

        # Test de rappel
        print("\nüîç Test de rappel de contexte...")

        recall_tests = [
            ("Quel est mon pr√©nom ?", "david"),
            ("Qu'est-ce que j'aime ?", "python"),
            ("Sur quoi je travaille ?", "ia"),
        ]

        for question, keyword in recall_tests:
            print(f"\n   Q: {question}")
            try:
                result = await self.orchestrator.process(user_input=question, user_id="david_test")

                response = result.get('response', '').lower()
                memory_context = result.get('memory_context', '')

                print(f"   R: {response[:100]}...")

                # V√©rifier si le contexte est pr√©sent
                has_context = len(memory_context) > 0

                self._record_test(
                    f"M√©moire: {question[:30]}", has_context, "Contexte pr√©sent" if has_context else "Pas de contexte"
                )

                await asyncio.sleep(0.5)

            except Exception as e:
                self._record_test(f"M√©moire: {question[:30]}", False, f"‚ùå Erreur: {e}")
                print(f"   ‚ùå Erreur: {e}")

        print("\n‚úÖ Test de m√©moire termin√©")

    async def _test_emotional_predictions(self):
        """Test 4: Pr√©dictions √©motionnelles"""
        print("\n" + "=" * 80)
        print("üîÆ TEST 4: PR√âDICTIONS √âMOTIONNELLES")
        print("=" * 80)

        # S√©quence √©motionnelle progressive
        emotional_sequence = [
            "Je suis un peu triste üòî",
            "√áa va mieux maintenant",
            "Je me sens vraiment bien ! üòä",
        ]

        print("\nüìù Test de trajectoire √©motionnelle...")

        for i, msg in enumerate(emotional_sequence, 1):
            print(f"\n  {i}. Message: {msg}")

            try:
                result = await self.orchestrator.process(user_input=msg, user_id="test_emotions")

                emotional_state = result.get('emotional_state', {})
                emotion = emotional_state.get('primary_emotion', 'neutre')

                print(f"     √âmotion: {emotion}")

                await asyncio.sleep(0.5)

            except Exception as e:
                print(f"     ‚ùå Erreur: {e}")

        self._record_test("Pr√©dictions: S√©quence compl√®te", True, "Trajectoire √©motionnelle test√©e")

        print("\n‚úÖ Test de pr√©dictions termin√©")

    async def _test_agi_systems(self):
        """Test 5: Syst√®mes AGI"""
        print("\n" + "=" * 80)
        print("üß† TEST 5: SYST√àMES AGI")
        print("=" * 80)

        status = self.orchestrator.get_system_status()
        agi_systems = status.get('agi_systems_active', [])

        print(f"\nüìã Syst√®mes AGI d√©tect√©s: {len(agi_systems)}")

        if agi_systems:
            print("\n   Syst√®mes actifs:")
            for i, system in enumerate(agi_systems, 1):
                print(f"   {i:2d}. {system}")

        # V√©rifier quelques syst√®mes cl√©s
        expected_systems = ['circadian_rhythm', 'creative_memory', 'dream_engine', 'emotional_journal']

        for system in expected_systems:
            is_active = system in agi_systems
            self._record_test(f"AGI: {system}", is_active, "‚úÖ Actif" if is_active else "‚ö†Ô∏è  Non actif")

        print("\n‚úÖ Test des syst√®mes AGI termin√©")

    async def _test_performance(self):
        """Test 6: Performance et m√©triques"""
        print("\n" + "=" * 80)
        print("üìä TEST 6: PERFORMANCE")
        print("=" * 80)

        status = self.orchestrator.get_system_status()
        perf = status.get('performance_metrics', {})

        print("\nüìà M√©triques de performance:")
        print(f"   Total requ√™tes: {perf.get('total_requests', 0)}")
        print(f"   Temps moyen: {perf.get('avg_response_time', 0):.3f}s")
        print(f"   Analyses √©motionnelles: {perf.get('emotional_analysis', 0)}")
        print(f"   Mises √† jour m√©moire: {perf.get('memory_updates', 0)}")

        # V√©rifications
        avg_time = perf.get('avg_response_time', 0)

        self._record_test("Performance: Temps de r√©ponse", avg_time < 5.0, f"{avg_time:.3f}s (seuil: < 5s)")

        self._record_test(
            "Performance: Requ√™tes trait√©es",
            perf.get('total_requests', 0) > 0,
            f"{perf.get('total_requests', 0)} requ√™tes",
        )

        # Stats d'apprentissage
        learning_stats = self.learning.get_learning_stats()

        print("\nüìö Statistiques d'apprentissage:")
        print(f"   Interactions: {learning_stats['total_interactions']}")
        print(f"   Patterns: {learning_stats['patterns_learned']}")
        print(f"   Qualit√©: {learning_stats['avg_response_quality']:.1%}")

        print("\n‚úÖ Test de performance termin√©")

    def _record_test(self, name: str, success: bool, details: str):
        """Enregistre un r√©sultat de test"""
        self.test_results['total_tests'] += 1

        if success:
            self.test_results['passed'] += 1
            status = '‚úÖ'
        elif 'warning' in details.lower() or '‚ö†Ô∏è' in details:
            self.test_results['warnings'] += 1
            status = '‚ö†Ô∏è'
        else:
            self.test_results['failed'] += 1
            status = '‚ùå'

        self.test_results['tests'].append(
            {
                'name': name,
                'status': status,
                'success': success,
                'details': details,
                'timestamp': datetime.now().isoformat(),
            }
        )

    def _generate_report(self):
        """G√©n√®re le rapport final"""
        print("\n" + "=" * 80)
        print("üìä RAPPORT FINAL - MEGA TEST JEFFREY ULTIMATE")
        print("=" * 80)

        total = self.test_results['total_tests']
        passed = self.test_results['passed']
        failed = self.test_results['failed']
        warnings = self.test_results['warnings']

        success_rate = (passed / total * 100) if total > 0 else 0

        print("\nüìà R√âSULTATS GLOBAUX:")
        print(f"   Total tests: {total}")
        print(f"   ‚úÖ R√©ussis: {passed}")
        print(f"   ‚ùå √âchou√©s: {failed}")
        print(f"   ‚ö†Ô∏è  Warnings: {warnings}")
        print(f"   üìä Taux de r√©ussite: {success_rate:.1f}%")

        # Score global
        if success_rate >= 90:
            grade = "üèÜ EXCELLENT"
            emoji = "üéâ"
        elif success_rate >= 75:
            grade = "‚úÖ TR√àS BON"
            emoji = "üëç"
        elif success_rate >= 60:
            grade = "‚ö†Ô∏è  ACCEPTABLE"
            emoji = "ü§î"
        else:
            grade = "‚ùå √Ä AM√âLIORER"
            emoji = "üîß"

        print(f"\n{emoji} SCORE GLOBAL: {grade}")

        # D√©tail par test
        print("\nüìã D√âTAIL DES TESTS:")

        for test in self.test_results['tests']:
            print(f"   {test['status']} {test['name']}")
            print(f"      {test['details']}")

        # Sauvegarder le rapport
        self._save_report()

        print("\n" + "=" * 80)
        print("‚úÖ MEGA TEST TERMIN√â !")
        print("=" * 80)
        print(f"\nüìÑ Rapport sauvegard√©: test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")

    def _save_report(self):
        """Sauvegarde le rapport en JSON"""
        self.test_results['end_time'] = datetime.now().isoformat()
        self.test_results['duration'] = str(
            datetime.fromisoformat(self.test_results['end_time'])
            - datetime.fromisoformat(self.test_results['start_time'])
        )

        filename = f"test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(self.test_results, f, indent=2, ensure_ascii=False)


async def main():
    """Point d'entr√©e principal"""
    try:
        tester = JeffreyMegaTest()
        await tester.run_all_tests()
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Test interrompu par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur fatale: {e}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    asyncio.run(main())
